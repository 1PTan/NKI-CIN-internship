---
title: "Bakhoum et al 2018 scRNA-seq"
author: "Pedro Batista Tan"
date: "`r strftime(Sys.Date(), '%B %d %Y')`"
output: 
  html_document:
    toc: true
    number_sections: true
---
# Loading Packages
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, warning=FALSE, message = FALSE, dpi = 300
  # fig.width = 10, fig.height = 6, output: html_notebook
)

# install.packages("BiocManager") #(only if you do not have BiocManager)
#BiocManager::install("DropletUtils")
# library(DropletUtils)
# install.packages("Seurat")
library(Seurat)
# install.packages("patchwork")
library(patchwork)
# install.packages("ggrepel")
library(ggrepel)
# install.packages("sparseMatrixStats")
library(sparseMatrixStats)
#install.packages("msigdbr")
library(msigdbr)
# BiocManager::install("GO.db")
library(GO.db)
# BiocManager::install("GOstats")
library(GOstats)
# BiocManager::install("org.Hs.eg.db")
library(org.Hs.eg.db)
# install.packages("tidyverse")
library(tidyverse)
# install.packages("proxy")
library(proxy)
# BiocManager::install("fgsea")
library(fgsea)
# install.packages('plotly')
library(plotly)
# install.packages('pheatmap')
library(pheatmap)
# install.packages("gplots")
library(gplots)

select = dplyr::select
rename = dplyr::rename
```

# Loading data
```{r}
# Load data from 10x into Seurat
if (FALSE) {
# For output from CellRanger < 3.0
data_dir <- 'path/to/data/directory'
list.files(data_dir) # Should show barcodes.tsv, genes.tsv, and matrix.mtx
expression_matrix <- Read10X(data.dir = data_dir)
seurat_object = CreateSeuratObject(counts = expression_matrix)

# For output from CellRanger >= 3.0 with multiple data types
data_dir <- 'path/to/data/directory'
list.files(data_dir) # Should show barcodes.tsv.gz, features.tsv.gz, and matrix.mtx.gz
data <- Read10X(data.dir = data_dir)
seurat_object = CreateSeuratObject(counts = data$`Gene Expression`)
seurat_object[['Protein']] = CreateAssayObject(counts = data$`Antibody Capture`)
}


data_dir <- 'data/CINdata/kif2b/'
list.files(data_dir) # Should show barcodes.tsv, genes.tsv, and matrix.mtx
kif2b_expression_matrix <- Read10X(data.dir = data_dir)
kif2b = CreateSeuratObject(counts = kif2b_expression_matrix, project = "kif2b")

data_dir <- 'data/CINdata/MCAK/'
MCAK_expression_matrix <- Read10X(data.dir = data_dir)
MCAK = CreateSeuratObject(counts = MCAK_expression_matrix, project = "MCAK")

data_dir <- 'data/CINdata/MCAK-Hypir/'
dnMCAK_expression_matrix <- Read10X(data.dir = data_dir)
dnMCAK = CreateSeuratObject(counts = dnMCAK_expression_matrix, project = "dnMCAK")


export = FALSE

# generate output dir path named data
source.output.dir <- file.path("data")

# if source output dir does not exist, create it
if (!dir.exists(source.output.dir)) {
    dir.create(source.output.dir)
} else{
  print("Data folder already exists")
}

# Remove objects to free memory and clean up workspace 
rm(kif2b_expression_matrix)
rm(MCAK_expression_matrix)
rm(dnMCAK_expression_matrix)
rm(data_dir)
rm(source.output.dir)
```

# Inspecting dataset, QC plots
```{r}
# Load ensembl gene database
ensembl_db <- read.csv("EnsDb.Hsapiens.v86.csv")

# Check whether mitochondrial genes are present in the samples
mitochondrial_genes <- ensembl_db %>% filter(str_detect(symbol, "^MT-"))

mitochondrial_genes$symbol %in% rownames(kif2b) %>% sum()
mitochondrial_genes$symbol %in% rownames(MCAK) %>% sum() 
mitochondrial_genes$symbol %in% rownames(dnMCAK) %>% sum()

```

```{r}
# Compute the % of mitochondrial counts
kif2b[["percent.mt"]] <- PercentageFeatureSet(kif2b, pattern = "^MT-") %>% mutate_all(~replace(., is.na(.), 0))
MCAK[["percent.mt"]] <- PercentageFeatureSet(MCAK, pattern = "^MT-") %>% mutate_all(~replace(., is.na(.), 0))
dnMCAK[["percent.mt"]] <- PercentageFeatureSet(dnMCAK, pattern = "^MT-") %>% mutate_all(~replace(., is.na(.), 0))
```

```{r}
# QC plots based on number of counts, features and % of mitochondrial genes

VlnPlot(kif2b, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(MCAK, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(dnMCAK, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

FeatureScatter(kif2b, feature1 = "nCount_RNA", feature2 = "percent.mt") +
FeatureScatter(kif2b, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

FeatureScatter(MCAK, feature1 = "nCount_RNA", feature2 = "percent.mt") +
FeatureScatter(MCAK, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

FeatureScatter(dnMCAK, feature1 = "nCount_RNA", feature2 = "percent.mt") +
FeatureScatter(dnMCAK, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

```

# Filter datasets
```{r}
# Filter dataset based on # of features, counts and mitocondrial %
kif2b_f <- subset(kif2b, subset = nFeature_RNA > 200 & percent.mt < 15 & nCount_RNA > 5000)
MCAK_f <- subset(MCAK, subset = nFeature_RNA > 200 & percent.mt < 15 & nCount_RNA > 5000)
dnMCAK_f <- subset(dnMCAK, subset = nFeature_RNA > 200 & percent.mt < 15 & nCount_RNA > 5000)

kif2b_f
MCAK_f
dnMCAK_f

nrow(kif2b_f@meta.data) + nrow(MCAK_f@meta.data) + nrow(dnMCAK_f@meta.data)
```

```{r}
# QC plots after filtering
VlnPlot(kif2b_f, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(MCAK_f, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(dnMCAK_f, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

FeatureScatter(kif2b_f, feature1 = "nCount_RNA", feature2 = "percent.mt") +
FeatureScatter(kif2b_f, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

FeatureScatter(MCAK_f, feature1 = "nCount_RNA", feature2 = "percent.mt") +
FeatureScatter(MCAK_f, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

FeatureScatter(dnMCAK_f, feature1 = "nCount_RNA", feature2 = "percent.mt") +
FeatureScatter(dnMCAK_f, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

```

```{r}
# Remove objects to free memory and clean up workspace 
rm(kif2b)
rm(MCAK)
rm(dnMCAK)
rm(mitochondrial_genes)
rm(ensembl_db)

```

# Combine and analyse datasets
```{r}
# Combine datasets
scRNA_c <- merge(kif2b_f, y = c(MCAK_f, dnMCAK_f), add.cell.ids = c("kif2b", "MCAK", "dnMCAK"), project = "BakhoumCIN2018")

scRNA_c
# colnames(scRNA_c) %>% head()
# colnames(scRNA_c) %>% tail()

```

```{r}
median_library_size <- scRNA_c@assays$RNA %>% colSums() %>% median()

# Normalize dataset
scRNA_cn <- NormalizeData(scRNA_c, normalization.method = "LogNormalize", scale.factor = median_library_size)

# find highly variable features with a variance stabilizing transform
scRNA_cn <- FindVariableFeatures(scRNA_cn, selection.method = "vst", nfeatures = 2000)

VariableFeaturePlot(scRNA_cn) %>% LabelPoints(points = head(VariableFeatures(scRNA_cn), 30), repel = TRUE)

# Scale dataset
scRNA_cn <- ScaleData(scRNA_cn, features = rownames(scRNA_cn))

# Add CIN status meta data
scRNA_cn@meta.data <- scRNA_cn@meta.data %>% mutate(CIN_status = ifelse(orig.ident %in% c("dnMCAK"),"CIN-high","CIN-low"))

```
## Perform PCA
```{r}
# Perform PCA
scRNA_cn <- RunPCA(scRNA_cn, features = VariableFeatures(object = scRNA_cn), npcs = 200)

# Plot PCA results
Idents(scRNA_cn) <- "orig.ident"
VizDimLoadings(scRNA_cn, dims = 1:2, reduction = "pca")
DimPlot(scRNA_cn, reduction = "pca")
ElbowPlot(scRNA_cn, ndims = 200)

DimHeatmap(scRNA_cn, dims = 1:10, cells = 500, balanced = TRUE)

# Check the total variance explained
# On Seurat 3:
pca <- scRNA_cn[["pca"]]
# Get the total variance of the scaled counts matrix:
mat <- Seurat::GetAssayData(scRNA_cn, assay = "RNA", slot = "scale.data")
mat <- mat[rownames(mat) %in% VariableFeatures(scRNA_cn), ]

total_variance <- sum(matrixStats::rowVars(mat))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance

varExplained

cumsum(varExplained) %>% as.data.frame() %>% rename("cumvar" = ".") %>% ggplot(aes(x = c(1:200), y = cumvar)) + geom_point() + labs(x = "PC #", y = "Cumulative Variance")

rm(mat)
rm(pca)
#Perform PCA "manually" on the matrix to check Seurat % variance explained

# USV <- svd(mat)	
# ssqtotal <- sum(mat*mat)
# 
# T <- USV$u %*% diag(USV$d)
# head(T)
# P <- USV$v
# npc <- 200
# ssqtot <- 0 * (1:npc)
# for (i in 1:npc){
#   print(i)
#   Xest  <- T[,1:i] %*% t(P[,1:i])
#   ssqtot[i] <- 100 * (1-sum((mat-Xest)*(mat-Xest))/ssqtotal)
# }
# 
# ssq=c(ssqtot[1],ssqtot[2:10]-ssqtot[1:9])
# rawPCA <- data.frame(ssq=ssq,ssqtot=ssqtot)
# 
# rm(T)
# rm(P)
# rm(rawPCA)
# rm(Xest)
# rm(USV)

```

```{r}
# Compute a null distribution for feature scores by permuting 1% of the data multiple times and compare this with information within each PC to obtain a significance estimate
scRNA_cn <- JackStraw(scRNA_cn, num.replicate = 100, dims = 50)
scRNA_cn <- ScoreJackStraw(scRNA_cn, dims = 1:50)
JackStrawPlot(scRNA_cn, dims = 1:50)
# 1:50
```
## Cell cycle assignment
```{r}
# A list of cell cycle markers, from Tirosh et al, 2015, is loaded with Seurat.  We can
# segregate this list into markers of G2/M phase and markers of S phase
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes

# Assign and inspect cell cycle scores
scRNA_cn <- CellCycleScoring(scRNA_cn, s.features = s.genes, g2m.features = g2m.genes)

scRNA_cn[[]] %>% select(S.Score, G2M.Score, Phase) %>% mutate_if(is.character, as.factor) %>% summary()

Idents(scRNA_cn) <- "Phase"
RidgePlot(scRNA_cn, features = c("PCNA", "TOP2A", "MCM6", "MKI67"), ncol = 2)
Idents(scRNA_cn) <- "orig.ident"
RidgePlot(scRNA_cn, features = c("PCNA", "TOP2A", "MCM6", "MKI67"), ncol = 2)

```
## Run UMAP and TSNE
```{r}
# Dimensionality reduction with UMAP on variable features instead of PCs
scRNA_cn <- RunUMAP(scRNA_cn, reduction.use = NULL, features = VariableFeatures(scRNA_cn))

# Store this UMAP as a custom reduction
scRNA_cn[["UMAP_features"]] <- CreateDimReducObject(embeddings = scRNA_cn@reductions$umap@cell.embeddings, key = "UMAP_features", assay = DefaultAssay(scRNA_cn))

# Run UMAP and project in 3D dimensions
scRNA_cn <- RunUMAP(scRNA_cn, dims = 1:200, n.components = 3L)

# Store this UMAP as a custom reduction
scRNA_cn[["umap3d"]] <- CreateDimReducObject(embeddings = scRNA_cn@reductions$umap@cell.embeddings, key = "umap3d", assay = DefaultAssay(scRNA_cn))

# Dimensionality reduction with UMAP and tSNE on PCs
scRNA_cn <- RunUMAP(scRNA_cn, dims = 1:200)

scRNA_cn <- RunTSNE(scRNA_cn, dims.use = 1:200, reduction.use = "pca", perplexity = 30)

```
## Clustering cells
```{r}
scRNA_cn <- FindNeighbors(scRNA_cn, features = VariableFeatures(object = scRNA_cn))
scRNA_cn <- FindClusters(scRNA_cn, resolution = 0.5)

scRNA_cn <- StashIdent(scRNA_cn, save.name = "clusterID")

# Inspect cluster information
#head(Idents(scRNA_cn), 5)
Idents(scRNA_cn) <- "clusterID"

table(scRNA_cn$orig.ident)
table(scRNA_cn$clusterID)
prop.table(table(scRNA_cn$clusterID))
prop.table(table(scRNA_cn$clusterID, scRNA_cn$orig.ident), margin = 2)
prop.table(table(scRNA_cn$orig.ident, scRNA_cn$clusterID), margin = 2)

prop.table(table(scRNA_cn$CIN_status))
prop.table(table(scRNA_cn$clusterID, scRNA_cn$CIN_status), margin = 2)
prop.table(table(scRNA_cn$CIN_status, scRNA_cn$clusterID), margin = 2)
prop.table(table(scRNA_cn$Phase, scRNA_cn$CIN_status), margin = 2)

table(scRNA_cn$clusterID, scRNA_cn$CIN_status) %>% as.data.frame() %>% rename("clusterID" = Var1, "group" = Var2) %>% ggplot(aes(x = clusterID, y = group, fill = Freq)) + geom_tile() + scale_fill_distiller(palette = "PuBu") + geom_text(aes(label=Freq)) + labs(y = "", fill = "Number of cells")

```
```{r}
prop.table(table(scRNA_cn$Phase, scRNA_cn$clusterID), margin = 2)

cluster_assignment <- prop.table(table(scRNA_cn$CIN_status, scRNA_cn$clusterID), margin = 2) %>% as.data.frame() %>% rename("CIN_status" = Var1, "cluster" = Var2)

cluster_assignment$CIN_status <- gsub("-", "_", cluster_assignment$CIN_status)

cluster_assignment <- cluster_assignment %>% pivot_wider(values_from = Freq, names_from = CIN_status) %>% mutate(CIN_status = ifelse(CIN_high < 0.15, "CIN-low", "CIN-high"))

cluster_assignment
```

## Visualization
```{r}
DimPlot(scRNA_cn, reduction = "UMAP_features", group.by = "CIN_status")
DimPlot(scRNA_cn, reduction = "UMAP_features", group.by = "orig.ident")
DimPlot(scRNA_cn, reduction = "UMAP_features", group.by = "Phase")
DimPlot(scRNA_cn, reduction = "UMAP_features", group.by = "clusterID")

DimPlot(scRNA_cn, reduction = "umap", group.by = "CIN_status")
DimPlot(scRNA_cn, reduction = "umap", group.by = "orig.ident")
DimPlot(scRNA_cn, reduction = "umap", group.by = "Phase")
DimPlot(scRNA_cn, reduction = "umap", group.by = "clusterID")

DimPlot(scRNA_cn, reduction = "tsne", group.by = "CIN_status")
DimPlot(scRNA_cn, reduction = "tsne", group.by = "orig.ident")
DimPlot(scRNA_cn, reduction = "tsne", group.by = "Phase")
DimPlot(scRNA_cn, reduction = "tsne", group.by = "clusterID")

```

## 3D UMAP
```{r}
# Extract cell embedding information from Seurat Object
# umap_1 <- scRNA_cn[["umap3d"]]@cell.embeddings[,1]
# umap_2 <- scRNA_cn[["umap3d"]]@cell.embeddings[,2]
# umap_3 <- scRNA_cn[["umap3d"]]@cell.embeddings[,3]

# Visualize what headings are called so that you can extract them to form a dataframe
Embeddings(object = scRNA_cn, reduction = "umap") %>% head()
Embeddings(object = scRNA_cn, reduction = "umap3d") %>% head()

# Prepare a dataframe for cell plotting
plot.data <- FetchData(object = scRNA_cn, vars = c("umap3d_1", "umap3d_2", "umap3d_3", "seurat_clusters", "Phase", "orig.ident"))

# Make a column of row name identities (these will be your cell/barcode names)
plot.data$label <- paste(rownames(plot.data))

# Plot your data
#When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

fig <- plot_ly(data = plot.data, 
        x = ~umap3d_1, y = ~umap3d_2, z = ~umap3d_3, 
        color = ~seurat_clusters, 
        colors = c("lightseagreen", "gray50", "darkgreen", "red4", "red", "turquoise4",
                   "black", "yellow4", "royalblue1", "lightcyan3", "peachpuff3",
                   "khaki3", "gray20", "orange2", "royalblue4", "yellow3", "gray80",
                   "darkorchid1", "lawngreen", "plum2", "darkmagenta"),
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 3, width=2), # controls size of points
        text=~orig.ident,
        hoverinfo="text") 
fig

fig <- plot_ly(data = plot.data, 
        x = ~umap3d_1, y = ~umap3d_2, z = ~umap3d_3, 
        color = ~Phase,
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 3, width=2), # controls size of points
        text=~orig.ident,
        hoverinfo="text") 

fig

# Before you plot, set the ranges of the axis you desire. This set axis range will be 
# present across all clusters, and plotly will not adjust for axis length anymore
# this axis length will persist even when selecting some clusters

# xaxis
# axx <- list(nticks = 4,  range = c(-10,10))

# yaxis
# axy <- list(nticks = 4, range = c(-10,10))

#zaxis
# axz <- list(nticks = 4, range = c(-10,10))


# fig <- fig %>% layout(scene = list(xaxis=axx,yaxis=axy,zaxis=axz))
# fig_cube <- fig %>% layout(scene = list(xaxis=axx,yaxis=axy,zaxis=axz, aspectmode='cube')) # To maintain cubic aspect

rm(plot.data)
```


```{r}
# Say you wanto make a gene-expression 3D plot, where you can plot gene expression against a color scale
# Here using the same seurat object as above, we extract gene expression information for beta-actin 'ACTB'
# Here we concentrate on SCT normalized data, or log normalized RNA NOT raw counts.
# In addition if you want, you may look at normalised-RNA, SCT or integrated slots, to look at gene expression
# Setting your DefaultAssay() will inform R which assay to pick up expression data from.

# DefaultAssay(object = yourseuratobject)
# DefaultAssay(object = yourseuratobject) <- "RNA"
# DefaultAssay(object = yourseuratobject) <- "integrated"
# DefaultAssay(object = yourseuratobject) <- "SCT"

# create a dataframe
# plot.data <- FetchData(object = yourseuratobject, vars = c("UMAP_1", "UMAP_2", "UMAP_3", "ACTB"), slot = 'data')

# Say you want change the scale, so that every cell having an expression >1 will be one color
# Basically, you are re-adjusting the scale here, so that any cell having a certain expression will light up on your 3D plot

# First make another column in your dataframe, where all values above 1 are re-assigned a value of 1
# This information is stored in the 'changed' column of your dataframe

# plot.data$changed <- ifelse(test = plot.data$ACTB <1, yes = plot.data$ACTB, no = 1)

# Add the label column, so that now the column has 'cellname-its expression value'

# plot.data$label <- paste(rownames(plot.data)," - ", plot.data$ACTB, sep="")

# Plot your data, in this example my Seurat object had 21 clusters (0-20), and cells express a gene called ACTB

# you can just run this against the column for the gene as well using ~ACTB, the algorith will automatically scale in that case based on maximal and minimal values
# plot_ly(data = plot.data, 
#         x = ~UMAP_1, y = ~UMAP_2, z = ~UMAP_3, 
#         color = ~changed, 
#         opacity = .5,
#         colors = c('darkgreen', 'red'), 
#         type = "scatter3d", 
#         mode = "markers",
#         marker = list(size = 5, width=2), 
#         text=~label,
#         hoverinfo="text"
# )

# On running this code the HTML output should appear in RStudio. You can save the output as a
# HTML file. Once you have saved, just open the HTML file in any web browser (double click on the html- file
# and if asked select to open with any web browser like google chrome/safari/mozilla/explorer etc).
# It should be have all of the integrated features you saw in the RStudio output file.
```

## Cluster markers
```{r} 
# Find cluster markers 
Idents(scRNA_cn) <- "clusterID"
cluster.DE <- FindAllMarkers(scRNA_cn, min.pct = 0.05, logfc.threshold = 0)

#cluster.markers
clustertop10 <- cluster.DE %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)

cluster.DE %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)

```
## Plotting signatures
```{r}
Idents(scRNA_cn) <- "clusterID"

DoHeatmap(scRNA_cn, features = clustertop10$gene) + NoLegend()

# Plotting EMT signature 
EMT_signature <- c("VIM", "ZEB2", "SNAI2", "ZEB1")

VlnPlot(scRNA_cn, features = EMT_signature)

Idents(scRNA_cn) <- "CIN_status"

VlnPlot(scRNA_cn, features = EMT_signature)


EMT_signature2 <- c("EZH", "JUN", "VIM", "STEAP1", "SOX4", "MMP14", "SHH", "TIMP1", "ZEB1")

EMT_signature2 <- EMT_signature2[EMT_signature2 %in% rownames(scRNA_cn@assays$RNA)]

Idents(scRNA_cn) <- "CIN_status"
for(i in 1:length(EMT_signature2)){
p <- VlnPlot(scRNA_cn, features = EMT_signature2[i])
print(p)
}

Idents(scRNA_cn) <- "clusterID"
for(i in 1:length(EMT_signature2)){
p <- VlnPlot(scRNA_cn, features = EMT_signature2[i])
print(p)
}

```

```{r}
# Plotting Genes enriched in the "M" Population from Bakhoum et al
M_markers = c("ITGB5", "ITGB1", "ITGA5", "ITGA10", "IGFBP4", "FN1", "DSC2", "CXCL1","CTNNB1", "BMP4", "BCL2L1")

Idents(scRNA_cn) <- "CIN_status"
for(i in 1:length(M_markers)){
p <- VlnPlot(scRNA_cn, features = M_markers[i])
print(p)
}

Idents(scRNA_cn) <- "clusterID"
for(i in 1:length(M_markers)){
p <- VlnPlot(scRNA_cn, features = M_markers[i])
print(p)
p <- FeaturePlot(scRNA_cn, features = M_markers[i])
print(p)
}
```


```{r}
Idents(scRNA_cn) <- "clusterID"

for(i in 1:length(M_markers)){
p <- VlnPlot(scRNA_cn, features = M_markers[i])
print(p)
p <- FeaturePlot(scRNA_cn, features = M_markers[i])
print(p)
}
```

```{r}
# Plot CIN signature from Bakhoum et al 2018 (Supp. table 5), comparing CIN high and CIN low
CIN_signature <- c('PELI2','BMP2','SHH','TNS4','RAB3B','ROBO1','ARHGAP28','CHN2','CST1','F13A1','CPVL','SEMA6D','NHSL2','GTF2IP7','DPYSL3','PCDH7','KHDRBS3','TRAC','TMEM156',
'CST4','CD24','FGF5','NTN4')

CIN_present <- CIN_signature %in% rownames(scRNA_cn@assays$RNA)

Idents(scRNA_cn) <- "CIN_status"

for(i in 1:length(CIN_present)){
p <- VlnPlot(scRNA_cn, features = CIN_signature[CIN_present][i])
print(p)
p <- FeaturePlot(scRNA_cn, features = CIN_signature[CIN_present][i])
print(p)
}

```

## CIN DE
```{r}
# Plot gene expression of CIN high x low cells

Idents(scRNA_cn) <- "CIN_status"

# Subset data
CIN_high <- subset(scRNA_cn, idents = "CIN-high")
CIN_low <- subset(scRNA_cn, idents = "CIN-low")

# Calculate average gene expression for CIN high and low cells
avg.CINhigh.cells <- as.data.frame(AverageExpression(CIN_high, verbose = FALSE)$RNA) %>% rename("CIN_high" = all) %>% rownames_to_column("gene")

avg.CINlow.cells <- as.data.frame(AverageExpression(CIN_low, verbose = FALSE)$RNA) %>% rename("CIN_low" = all) %>% rownames_to_column("gene")


# Plot CIN high x cin low pseudocounts in log space
avg.CINhigh.cells %>% full_join(avg.CINlow.cells, by = "gene") %>% ggplot(aes(x = CIN_low, y = CIN_high)) + geom_point() + scale_y_continuous(trans = "log1p") + scale_x_continuous(trans = "log1p")

# avg.CINhigh.cells %>% full_join(avg.CINlow.cells, by = "gene") %>% mutate(fc = (CIN_high + 1)/(CIN_low + 1), log2fc = log2(fc)) %>% filter(gene %in% c("LAPTM5", "MARCKSL1", "HLA-B"))

```

```{r}
# Find CIN-high markers based on DE 
Idents(scRNA_cn) <- "CIN_status"

table(scRNA_cn$orig.ident, scRNA_cn$CIN_status)
# obs Try using min.pct lower, 
# ?FindMarkers 

CIN.DE <- FindMarkers(scRNA_cn, ident.1 = "CIN-high", min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")

CIN.top <- CIN.DE %>% top_n(n = 25, wt = avg_log2FC)

DoHeatmap(scRNA_cn, features = CIN.top$gene)
```

## Use only subpopulation M
```{r}
cluster.M <- FindMarkers(scRNA_cn, ident.1 = c(3,4), min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene") %>% mutate(cluster = "3,4")

cluster.M %>% write.csv2("data/scRNA_clusterM.csv", row.names = FALSE)
```

```{r}
# Compare with Bakhoum CIN gene signature
CIN_signature_df <- CIN_signature %>% as.data.frame() %>% rename('gene' = ".") %>% mutate(Bakhoum_gene_sig = TRUE)

CIN.DE %>% left_join(CIN_signature_df) %>% filter(Bakhoum_gene_sig)
#CIN.cluster.markers %>% filter(str_detect(gene, "BMP2"))
```


```{r}
# Plot gene expression of CIN high x low cells, labeling DE genes
DE_comp <- avg.CINhigh.cells %>% full_join(avg.CINlow.cells, by = "gene") %>% left_join(
  CIN.DE %>% mutate(CIN_DE = TRUE, label = p_val_adj < 1e-260)  %>% select(gene, CIN_DE, label)
)

DE_comp %>% ggplot(aes(x = CIN_low, y = CIN_high, col = CIN_DE)) + geom_point() +
  geom_text_repel(
  aes(x = CIN_low, y = CIN_high, label = gene), data = DE_comp %>% filter(label), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
  ) + theme(legend.position = "none") + scale_y_continuous(trans = "log1p") + scale_x_continuous(trans = "log1p")

rm(DE_comp)
rm(avg.CINhigh.cells)
rm(avg.CINlow.cells)
rm(CIN_high)
rm(CIN_low)

```

## Compare with Bulk CIN DE - gene correlation
```{r}
CIN.DE.bulk <- read_csv2("data/bulk_transcriptomics_deseq.csv")

CIN.DE.c <- CIN.DE.bulk %>% inner_join(CIN.DE %>% rename("symbol" = gene))

CIN.DE.c %>% ggplot(aes(x = log2FoldChange, y = avg_log2FC)) + geom_point(alpha = 0.3, col = "blue") + geom_abline(slope = 1, col = "blue", alpha = 0.5) + labs(title = "CIN-High x CIN-Low Log2FC", x = "Bulk transcriptomics", y = "scRNA-seq transcriptomics") + geom_text_repel(
  aes(x = log2FoldChange, y = avg_log2FC, label = symbol), data = CIN.DE.c %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  )

cor(CIN.DE.c$log2FoldChange, CIN.DE.c$avg_log2FC)

# Check agreement between the sign of genes
table(sign(CIN.DE.c$log2FoldChange), sign(CIN.DE.c$avg_log2FC))
prop.table(table(sign(CIN.DE.c$log2FoldChange), sign(CIN.DE.c$avg_log2FC)))
```
```{r}
CIN.DE.c %>% ggplot(aes(avg_log2FC/log2FoldChange)) + geom_histogram(col = "blue", bins = 1000) + labs(title = "CIN-High x CIN-Low", x = "scRNA-seq/Bulk Log2FC transcriptomics", y = "Count")

CIN.DE.c %>% ggplot(aes(avg_log2FC/log2FoldChange)) + geom_histogram(col = "blue", bins = 100) + labs(title = "CIN-High x CIN-Low", x = "scRNA-seq/Bulk Log2FC transcriptomics", y = "Count") + xlim(-10, 10)


CIN.DE.c %>% mutate(sc_bulk_ratio = avg_log2FC/log2FoldChange) %>% select(sc_bulk_ratio) %>% summary()

```

## Export
```{r}
if(export){
saveRDS(scRNA_cn, file = "data/Bakhoum_scRNA.rds")
  
cluster.DE %>% write.csv2("data/Bakhoum_scRNA_cluster_markers.csv", row.names = FALSE)

CIN.DE %>% write.csv2("data/Bakhoum_scRNA_CIN_cluster_markers.csv", row.names = FALSE)

# Export data for pre ranked GSEA
# Convert p-values of zero to 1e-300, then calculate the preranking statistic and export
CIN.DE %>% mutate(
  p_val = ifelse(p_val == 0, 1e-300, p_val),
  signlogFC_pval = sign(avg_log2FC) * -log10(p_val)
  ) %>% select(gene, signlogFC_pval) %>% rename("NAME" = gene) %>% write.table("data/Bakhoum_scRNA_CIN_Highlow_GSEA_pval.rnk", sep = "\t", row.names = FALSE, quote = FALSE)

CIN.DE %>% select(gene, avg_log2FC) %>% rename("NAME" = gene) %>% write.table("data/Bakhoum_scRNA_CIN_Highlow_GSEA_fc.rnk", sep = "\t", row.names = FALSE, quote = FALSE)

}

scRNA_cn <- readRDS(file = "data/Bakhoum_scRNA.rds")
cluster.DE <- read.csv2("data/Bakhoum_scRNA_cluster_markers.csv")
CIN.DE <- read.csv2("data/Bakhoum_scRNA_CIN_cluster_markers.csv")

```

## Load msigdb hallmarks gene set
```{r}
all_gene_sets <- msigdbr("Homo sapiens")

msigdb_hallmarks_set <- filter(all_gene_sets, gs_cat == "H") %>% select(gs_name, gene_symbol)

msigdb_hallmarks_set <- split(msigdb_hallmarks_set$gene_symbol, msigdb_hallmarks_set$gs_name)

msigdb_hallmarks_names <- read.csv2("data/names_hallmarks.csv")

rm(all_gene_sets)
# Another option is loading files with gene sets
# msigdb_hallmarks <- gmtPathways("data/h.all.v7.4.symbols.gmt")
# msigdb_hallmarks %>% head() %>% lapply(head)

```

## Inspect msigdb hallmark gene sets and overlaps
```{r}
# Set up empty data frame
hallmark_gene_df <- setNames(data.frame(matrix(ncol = 2, nrow = 0)), c("gene", "pathway"))

# Populate data frame with genes from each pathway
for(i in 1:length(msigdb_hallmarks_set)){
  hallmark_pathway = names(msigdb_hallmarks_set)[[i]]
  print(paste(i, hallmark_pathway))
  
  hallmark_gene_df <- rbind(hallmark_gene_df, msigdb_hallmarks_set[[i]] %>% as.data.frame() %>% rename("gene" = ".") %>% mutate(pathway = hallmark_pathway))
}

# Make the dataframe wide with pathways as columns
hallmark_gene_df_wide <- hallmark_gene_df %>% mutate(value = TRUE) %>% pivot_wider(values_from = value, names_from = pathway) %>% mutate_all(~replace(., is.na(.), FALSE))

# vars.to.replace = colnames(hallmark_gene_df_wide)
# Replace NA values with FALSE
# hallmark_gene_df_wide[vars.to.replace][is.na(hallmark_gene_df_wide[vars.to.replace])] <- FALSE

# number of genes in each pathway / pathways in each gene
hallmark_gene_df_wide %>% column_to_rownames("gene") %>% colSums()
# hallmark_gene_df_wide %>% column_to_rownames("gene") %>% rowSums()
```

```{r}
# Inspect particular hallmark pathways
hallmark_gene_df_wide %>% select(gene, HALLMARK_INFLAMMATORY_RESPONSE, HALLMARK_INTERFERON_ALPHA_RESPONSE, HALLMARK_INTERFERON_GAMMA_RESPONSE, HALLMARK_TGF_BETA_SIGNALING) %>% filter(HALLMARK_INFLAMMATORY_RESPONSE) %>% view()

# Calculate and inspect the Jaccard distance between pathways
hallmark_jaccard_distances <- hallmark_gene_df_wide %>% column_to_rownames("gene") %>% proxy::dist(method = "Jaccard", by_rows = FALSE)

hallmark_jaccard_distances <- hallmark_jaccard_distances %>% as.matrix() %>% as.data.frame()

hallmark_jaccard_distances %>% summary()

hallmark_jaccard_distances %>% select(HALLMARK_INFLAMMATORY_RESPONSE, HALLMARK_INTERFERON_ALPHA_RESPONSE, HALLMARK_INTERFERON_GAMMA_RESPONSE, HALLMARK_TGF_BETA_SIGNALING) %>% view()

```

```{r}
# Get genes shared between specific hallmarks
sum(hallmark_gene_df_wide$HALLMARK_INFLAMMATORY_RESPONSE * hallmark_gene_df_wide$HALLMARK_INTERFERON_ALPHA_RESPONSE)

INFR_EMT <- hallmark_gene_df_wide %>% column_to_rownames("gene") %>% filter(HALLMARK_INFLAMMATORY_RESPONSE * HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION == 1) %>% rownames()

INFR_IFNa <- hallmark_gene_df_wide %>% column_to_rownames("gene") %>% filter(HALLMARK_INFLAMMATORY_RESPONSE * HALLMARK_INTERFERON_ALPHA_RESPONSE == 1) %>% rownames()

INFR_IFNy <- hallmark_gene_df_wide %>% column_to_rownames("gene") %>% filter(HALLMARK_INFLAMMATORY_RESPONSE * HALLMARK_INTERFERON_GAMMA_RESPONSE == 1) %>% rownames()

INFR_TGFB <- hallmark_gene_df_wide %>% column_to_rownames("gene") %>% filter(HALLMARK_INFLAMMATORY_RESPONSE * HALLMARK_TGF_BETA_SIGNALING == 1) %>% rownames()

IFNa_IFNy <- hallmark_gene_df_wide %>% column_to_rownames("gene") %>% filter(HALLMARK_INTERFERON_ALPHA_RESPONSE * HALLMARK_INTERFERON_GAMMA_RESPONSE == 1) %>% rownames()


```

## CIN High x CIN Low
## FGSEA
```{r}
CIN_fc_rnk <- CIN.DE %>% select(gene, avg_log2FC) %>% deframe()

fgseaRes <- fgsea(pathways = msigdb_hallmarks_set, 
                  stats    = CIN_fc_rnk,
                  minSize  = 15,
                  maxSize  = 500)

fgseaRes <- fgseaRes %>% mutate(within_threshold = pval < 0.05, "Enriched_in" = ifelse(NES > 0, "CIN-high", "CIN-low")) %>% left_join(msigdb_hallmarks_names)

plotEnrichment(msigdb_hallmarks_set[["HALLMARK_KRAS_SIGNALING_UP"]],
               CIN_fc_rnk) + labs(title="KRAS Signaling")

plotEnrichment(msigdb_hallmarks_set[["HALLMARK_INFLAMMATORY_RESPONSE"]],
               CIN_fc_rnk) + labs(title="Inflammatory Response")

#fgseaRes %>% select(-leadingEdge) %>% write.csv2("data/fgsea_cin_high_low.csv")

fgseaRes %>% mutate(pval = ifelse(pval < 0.0001, 0.000101, pval)) %>% ggplot(aes(x = log10(pval), y = NES)) +
  geom_point(aes(size = 0.5, alpha = 0.3, col = Enriched_in)) + 
  geom_hline(yintercept = 0, col = "black") +
  geom_text_repel(
  aes(x = log10(pval), y = NES, label = name), data = fgseaRes %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
  ) +
  labs(x = "log10(pval)", y = "Normalized Enrichment Score", col = "Enriched in") + 
  scale_y_continuous(limits = c(-2,2), breaks = seq(-2,2,1)) + 
  scale_x_continuous(trans = "reverse", limits = c(0, -4), breaks = c(-4, -3, -2, -1, 0) , labels = c("<0.0001", "0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)

if (export){
png(filename="data/fGSEA_scRNA_results_fc.png", width=800, height=500)
ggsave(file="data/fGSEA_scRNA_results_fc.png", width=8, height=5, dpi=300)
}

# topPathways <- c(fgseaRes[ES > 0][head(order(pval), n=5), pathway],
#                  rev(fgseaRes[ES < 0][head(order(pval), n=5), pathway]))
# 
# plotGseaTable(msigdb_hallmarks_set[topPathways], CIN_fc_rnk, fgseaRes, gseaParam=0.5, render = TRUE)

if(export){
  fgseaRes %>% select(-leadingEdge) %>% write.csv2("data/scRNA_fgsea_CIN_highlow.csv", row.names = FALSE)
}

fgseaRes <- read.csv2("data/scRNA_fgsea_CIN_highlow.csv")
```

## GSEA
```{r}
msigdb_hallmarks_names <- read.csv2("data/names_hallmarks.csv")

# GSEA results
GSEA_pos <- read.table("data/scRNA_cinhighlow_hallmarks_fc.GseaPreranked.1619184220473/gsea_report_for_na_pos_1619184220473.tsv", header = TRUE, sep = "\t")

GSEA_neg <- read.table("data/scRNA_cinhighlow_hallmarks_fc.GseaPreranked.1619184220473/gsea_report_for_na_neg_1619184220473.tsv", header = TRUE, sep = "\t")

GSEA_res <- rbind(GSEA_pos, GSEA_neg) %>% mutate(within_threshold = FDR.q.val < 0.3) %>% mutate("Enriched_in" = ifelse(NES > 0, "CIN-high", "CIN-low")) %>% left_join(msigdb_hallmarks_names %>% dplyr::rename("NAME" = pathway))

GSEA_res %>% mutate(pval = ifelse(FDR.q.val < 0.001, 0.00101, FDR.q.val)) %>% 
  ggplot(aes(x = log10(FDR.q.val), y = NES)) +
  geom_point(aes(size = 0.5, alpha = 0.3, col = Enriched_in)) + 
  geom_hline(yintercept = 0, col = "black") +
  geom_text_repel(
  aes(x = log10(FDR.q.val), y = NES, label = name), data = GSEA_res %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
  ) +
  labs(x = "log10(FDRq)", y = "Normalized Enrichment Score", col = "Enriched in") + 
  scale_y_continuous(limits = c(-2,2), breaks = seq(-2,2,1)) + 
  scale_x_continuous(trans = "reverse", limits = c(0, -3), breaks = c(-3, -2, -1, 0) , labels = c("<0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)

if (export){
png(filename="data/GSEA_scRNA_results_fc.png", width=800, height=500)
ggsave(file="data/GSEA_scRNA_results_fc.png", width=8, height=5, dpi=300)
}

# GSEA_pos <- read.table("data/scRNA_cinhighlow_hallmarks_pval.GseaPreranked.1619184161366/gsea_report_for_na_pos_1619184161366.tsv", header = TRUE, sep = "\t")
# 
# GSEA_neg <- read.table("data/scRNA_cinhighlow_hallmarks_pval.GseaPreranked.1619184161366/gsea_report_for_na_neg_1619184161366.tsv", header = TRUE, sep = "\t")
# 
# GSEA_res <- rbind(GSEA_pos, GSEA_neg) %>% mutate(within_threshold = FDR.q.val < 0.3) %>% mutate("Enriched_in" = ifelse(NES > 0, "CIN-high", "CIN-low"))  %>% left_join(msigdb_hallmarks_names %>% dplyr::rename("NAME" = pathway))
# 
# GSEA_res %>% mutate(pval = ifelse(FDR.q.val < 0.001, 0.00101, FDR.q.val)) %>% 
#   ggplot(aes(x = log10(FDR.q.val), y = NES)) +
#   geom_point(aes(size = 0.5, alpha = 0.3, col = Enriched_in)) + 
#   geom_hline(yintercept = 0, col = "black") +
#   geom_text_repel(
#   aes(x = log10(FDR.q.val), y = NES, label = name), data = GSEA_res %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
#   ) +
#   labs(x = "log10(FDRq)", y = "Normalized Enrichment Score", col = "Enriched in") + 
#   scale_y_continuous(limits = c(-2,2), breaks = seq(-2,2,1)) + 
#   scale_x_continuous(trans = "reverse", limits = c(0, -3), breaks = c(-3, -2, -1, 0) , labels = c("<0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)
# 
# if (export){
# png(filename="data/GSEA_scRNA_results_pval.png", width=800, height=500)
# ggsave(file="data/GSEA_scRNA_results_pval.png", width=8, height=5, dpi=300)
# }

rm(GSEA_pos)
rm(GSEA_neg)

```

## Compare with Bulk GSEA NES
```{r}
Bulk_gsea <- read.csv2("data/Supp_table6.csv")

# GSEA x Bulk
GSEA_comp <- Bulk_gsea %>% select(NAME, NES, FDR.q.val) %>% rename(BULK_NES = NES, BULK_FDR.q.val = FDR.q.val) %>% left_join(
  GSEA_res %>% select(NAME, NES, FDR.q.val) %>% rename(scNES = NES, scFDR.q.val = FDR.q.val) 
) %>% left_join(
  msigdb_hallmarks_names %>% rename(NAME = pathway)
  ) %>% mutate(sign_agreement = sign(BULK_NES) == sign(scNES))

GSEA_comp %>% ggplot(aes(x = BULK_NES, y = scNES, col = scFDR.q.val)) + 
  geom_point() + geom_abline(slope = 1) + 
  geom_text_repel(
    aes(x = BULK_NES, y = scNES, label = name), data = GSEA_comp %>% filter(!sign_agreement), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  ) + labs(x = "Bulk GSEA NES", y = "scRNA GSEA NES")

# FGSEA x Bulk
fGSEA_comp <- Bulk_gsea %>% select(NAME, NES, FDR.q.val) %>% rename(BULK_NES = NES, BULK_FDR.q.val = FDR.q.val) %>% left_join(
  fgseaRes %>% select(pathway, NES, pval) %>% rename(NAME = pathway, scNES = NES, scpval = pval) 
) %>% left_join(
  msigdb_hallmarks_names %>% rename(NAME = pathway)
  ) %>% mutate(sign_agreement = sign(BULK_NES) == sign(scNES))

fGSEA_comp %>% ggplot(aes(x = BULK_NES, y = scNES, col = scpval)) + 
  geom_point() + geom_abline(slope = 1) + 
  geom_text_repel(
    aes(x = BULK_NES, y = scNES, label = name), data = GSEA_comp %>% filter(!sign_agreement), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  ) + labs(x = "Bulk GSEA NES", y = "scRNA fGSEA NES")
```

## Population "M" FGSEA
```{r}
M_rnk <- cluster.M %>% select(gene, avg_log2FC) %>% deframe()

M_fgseaRes <- fgsea(pathways = msigdb_hallmarks_set, 
                  stats    = M_rnk,
                  minSize  = 15,
                  maxSize  = 500)

M_fgseaRes <- M_fgseaRes %>% mutate(within_threshold = pval < 0.01, "Enriched_in" = ifelse(NES > 0, "Cluster 3,4", "Other clusters")) %>% left_join(msigdb_hallmarks_names)

plotEnrichment(msigdb_hallmarks_set[["HALLMARK_KRAS_SIGNALING_UP"]],
               M_rnk) + labs(title="KRAS Signaling")

plotEnrichment(msigdb_hallmarks_set[["HALLMARK_INFLAMMATORY_RESPONSE"]],
               M_rnk) + labs(title="Inflammatory Response")

plotEnrichment(msigdb_hallmarks_set[["HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION"]],
               M_rnk) + labs(title="Inflammatory Response")

#fgseaRes %>% select(-leadingEdge) %>% write.csv2("data/fgsea_cin_high_low.csv")

M_fgseaRes %>% mutate(pval = ifelse(pval < 0.00001, 0.0000101, pval)) %>% ggplot(aes(x = log10(pval), y = NES)) +
  geom_point(aes(size = 0.5, alpha = 0.3, col = Enriched_in)) + 
  geom_hline(yintercept = 0, col = "black") +
  geom_text_repel(
  aes(x = log10(pval), y = NES, label = name), data = M_fgseaRes %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 30
  ) +
  labs(x = "log10(pval)", y = "Normalized Enrichment Score", col = "Enriched in") + 
  scale_y_continuous(limits = c(-2,2), breaks = seq(-2,2,1)) + 
  scale_x_continuous(trans = "reverse", limits = c(0, -5), breaks = c(-5, -4, -3, -2, -1, 0) , labels = c("<0.00001", "0.0001", "0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)

# topPathways <- c(fgseaRes[ES > 0][head(order(pval), n=5), pathway],
#                  rev(fgseaRes[ES < 0][head(order(pval), n=5), pathway]))
# 
# plotGseaTable(msigdb_hallmarks_set[topPathways], CIN_fc_rnk, fgseaRes, gseaParam=0.5, render = TRUE)

if(export){
  M_fgseaRes %>% select(-leadingEdge) %>% write.csv2("data/scRNA_fgsea_M.csv", row.names = FALSE)
}

```

## Label hallmarks
```{r}
# Label genes from the inflammatory response
CIN.DE.c %>% filter(gene %in% msigdb_hallmarks_set$HALLMARK_INFLAMMATORY_RESPONSE) %>% ggplot(aes(x = log2FoldChange, y = avg_log2FC)) + geom_point(alpha = 0.3, col = "blue") + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + geom_abline(slope = 1, intercept = 0, color = "blue", alpha = 0.5) + labs(title = "CIN-High x CIN-Low Log2FC Inflammatory response", x = "Bulk transcriptomics", y = "scRNA-seq transcriptomics") + geom_text_repel(
  aes(x = log2FoldChange, y = avg_log2FC, label = symbol), data = CIN.DE.c %>% filter(gene %in% msigdb_hallmarks_set$HALLMARK_INFLAMMATORY_RESPONSE), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  )

# Label genes from the EMT
CIN.DE.c %>% filter(gene %in% msigdb_hallmarks_set$HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION) %>% ggplot(aes(x = log2FoldChange, y = avg_log2FC)) + geom_point(alpha = 0.3, col = "blue") + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + geom_abline(slope = 1, intercept = 0, color = "blue", alpha = 0.5) + labs(title = "CIN-High x CIN-Low Log2FC EMT", x = "Bulk transcriptomics", y = "scRNA-seq transcriptomics") + geom_text_repel(
  aes(x = log2FoldChange, y = avg_log2FC, label = symbol), data = CIN.DE.c %>% filter(gene %in% msigdb_hallmarks_set$HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  )


# Label genes in bulk CIN signature
CIN.DE.c %>% filter(gene %in% CIN_signature) %>% ggplot(aes(x = log2FoldChange, y = avg_log2FC)) + geom_point(alpha = 0.3, col = "blue") + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + geom_abline(slope = 1, intercept = 0, color = "blue", alpha = 0.5) + labs(title = "CIN-High x CIN-Low Log2FC INFR and TGFB", x = "Bulk transcriptomics", y = "scRNA-seq transcriptomics") + geom_text_repel(
  aes(x = log2FoldChange, y = avg_log2FC, label = symbol), data = CIN.DE.c %>% filter(gene %in% CIN_signature), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  )
```
## Clustering cells on EMT genes
```{r}
colfunc <- colorRampPalette(c("blue", "white", "red"))

# Get the total variance of the scaled counts matrix:
mat <- Seurat::GetAssayData(scRNA_cn, assay = "RNA", slot = "scale.data")
mat <- mat[rownames(mat) %in% msigdb_hallmarks_set$HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION, ]

# Z-score matrix counts
gene_means = rowMeans(mat)
gene_SDs = rowSds(mat)

# If the SD is zero, use 1 instead, it won't affect the mean number
# another option is to filter these genes out
gene_SDs[gene_SDs == 0] <- 1

Z_score_mat = (mat - gene_means)/gene_SDs

mat_annotation <- scRNA_cn@meta.data %>% select(orig.ident)

color_annotation <- list(orig.ident =  c("darkslategray3", "blue4", "red"))
names(color_annotation$orig.ident) <- unique(mat_annotation$orig.ident)

pheatmap(Z_score_mat, color = colfunc(100), show_colnames = FALSE, annotation_col = mat_annotation, annotation_colors = color_annotation, main = "pheatmap column scaling")

# Using threshold breaks at Z scores of 2.5
Z_score_mat_t <- Z_score_mat
Z_score_mat_t[Z_score_mat_t > 2.5] <- 2.5
Z_score_mat_t[Z_score_mat_t < -2.5] <- -2.5

pheatmap(Z_score_mat_t, color = colfunc(100), show_colnames = FALSE, annotation_col = mat_annotation, annotation_colors = color_annotation, main = "pheatmap column scaling")

rm(color_annotation)
rm(Z_score_mat_t)
rm(Z_score_mat)
rm(mat)
rm(gene_means)
rm(gene_SDs)
```

```{r}
# Label genes shared between inflamatory response and IFNa
CIN.DE.c %>% filter(gene %in% INFR_IFNa) %>% ggplot(aes(x = log2FoldChange, y = avg_log2FC)) + geom_point(alpha = 0.3, col = "blue") + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + geom_abline(slope = 1, intercept = 0, color = "blue", alpha = 0.5) + labs(title = "CIN-High x CIN-Low Log2FC INFR and IFNa", x = "Bulk transcriptomics", y = "scRNA-seq transcriptomics") + geom_text_repel(
  aes(x = log2FoldChange, y = avg_log2FC, label = symbol), data = CIN.DE.c %>% filter(gene %in% INFR_IFNa), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  )

# Label genes shared between inflamatory response and IFNy
CIN.DE.c %>% filter(gene %in% INFR_IFNy) %>% ggplot(aes(x = log2FoldChange, y = avg_log2FC)) + geom_point(alpha = 0.3, col = "blue") + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + geom_abline(slope = 1, intercept = 0, color = "blue", alpha = 0.5) + labs(title = "CIN-High x CIN-Low Log2FC INFR and IFNy", x = "Bulk transcriptomics", y = "scRNA-seq transcriptomics") + geom_text_repel(
  aes(x = log2FoldChange, y = avg_log2FC, label = symbol), data = CIN.DE.c %>% filter(gene %in% INFR_IFNy), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  )

# Label genes shared between inflamatory response and TGFB
CIN.DE.c %>% filter(gene %in% INFR_TGFB) %>% ggplot(aes(x = log2FoldChange, y = avg_log2FC)) + geom_point(alpha = 0.3, col = "blue") + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + geom_abline(slope = 1, intercept = 0, color = "blue", alpha = 0.5) + labs(title = "CIN-High x CIN-Low Log2FC INFR and TGFB", x = "Bulk transcriptomics", y = "scRNA-seq transcriptomics") + geom_text_repel(
  aes(x = log2FoldChange, y = avg_log2FC, label = symbol), data = CIN.DE.c %>% filter(gene %in% INFR_TGFB), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  )

```


## FGSEA DE between clusters
```{r}
cluster.DE.l <- cluster.DE %>% select(gene, cluster, avg_log2FC) %>% split(f = cluster.DE$cluster)

cluster.DE.fgsea <- cluster.DE.l %>% lapply(FUN = function(x){
  x <- x %>% select(-cluster) %>% deframe()
  x <- fgsea(pathways = msigdb_hallmarks_set, 
                  stats = x,
                  minSize = 15,
                  maxSize = 500)
})

# Plot results for the GSEA on each cluster 
lapply(seq_along(cluster.DE.fgsea), FUN = function(i){
  cluster.DE.fgsea[[i]] <- cluster.DE.fgsea[[i]] %>% mutate(
    within_threshold = pval < 0.05, 
    pval = ifelse(pval < 0.0001, 0.000101, pval)
    ) %>% left_join(msigdb_hallmarks_names)

  cluster.DE.fgsea[[i]] %>% ggplot(aes(x = log10(pval), y = NES)) +
  geom_point(aes(size = 0.5, alpha = 0.3, col = as.factor(sign(NES)))) + 
  geom_hline(yintercept = 0, col = "black") +
  geom_text_repel(
  aes(x = log10(pval), y = NES, label = name), data = cluster.DE.fgsea[[i]] %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
  ) +
  labs(x = "log10(pval)", y = "Normalized Enrichment Score", col = "Enriched in Cluster", title = paste("Cluster: ", i - 1, sep = "")) + 
  scale_y_continuous(limits = c(-3.5,3.5), breaks = seq(-3.5,3.5,0.5)) + 
  scale_x_continuous(trans = "reverse", limits = c(0, -4), breaks = c(-4, -3, -2, -1, 0) , labels = c("<0.0001", "0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)
})


# Combine summaries from the GO enrichment tests
cluster.DE.fgsea_summary <- cluster.DE.fgsea[[1]] %>% mutate(cluster = 0) %>% filter(pval == "nothing")

for(i in 1:length(cluster.DE.fgsea)){
  print(i)
  cluster.DE.fgsea_summary <- rbind(
    cluster.DE.fgsea_summary, 
    cluster.DE.fgsea[[i]] %>% mutate(cluster = i-1)
    )
}

if(export){
cluster.DE.fgsea_summary %>% select(-leadingEdge) %>% write.csv2("data/scRNA_cluster_fgsea.csv", row.names = FALSE)
}

cluster.DE.fgsea_summary <- read.csv2("data/scRNA_cluster_fgsea.csv")
cluster.DE.fgsea <- cluster.DE.fgsea_summary %>% split(f = cluster.DE.fgsea_summary$cluster)

```
## Heatmap Cluster NES
```{r}
colfunc <- colorRampPalette(c("blue", "white", "red"))

cluster.DE.fgsea_summary %>% left_join(msigdb_hallmarks_names) %>% select(name, NES, cluster) %>% pivot_wider(values_from = NES, names_from = name) %>% column_to_rownames("cluster") %>% mutate_all(~replace(., is.na(.), 0)) %>% as.matrix() %>% pheatmap(color = colfunc(10))


cluster.DE.fgsea_summary %>% left_join(msigdb_hallmarks_names) %>% select(name, NES, cluster) %>% pivot_wider(values_from = NES, names_from = name)  %>% 
  column_to_rownames(var = "cluster") %>% mutate_all(~replace(., is.na(.), 0)) %>% as.matrix() %>%
  heatmap.2(col=colfunc(10), dendrogram = "both", trace = "none", srtCol = 75)

```

```{r}
DimPlot(scRNA_cn, reduction = "UMAP_features", group.by = "CIN_status")
DimPlot(scRNA_cn, reduction = "UMAP_features", group.by = "orig.ident")
DimPlot(scRNA_cn, reduction = "UMAP_features", group.by = "Phase")
DimPlot(scRNA_cn, reduction = "UMAP_features", group.by = "clusterID")

```

## Entrez ID symbol Mapping
```{r}
# Map symbols to entrezids using Annotation dbi
entrez_dbi_map <- cluster.DE %>% select(gene) %>% unique()

entrez_dbi_map$entrezid <- mapIds(org.Hs.eg.db,
                    keys=entrez_dbi_map$gene,
                    column="ENTREZID",
                    keytype="SYMBOL",
                    multiVals="first")

entrez_dbi_map %>% filter(is.na(entrezid)) %>% n_distinct() 
entrez_dbi_map %>% filter(!is.na(entrezid)) %>% n_distinct()
```

## GO BP Enrichment
```{r}
cluster.DE.l <- cluster.DE %>% select(gene, p_val, cluster, avg_log2FC) %>% split(f = cluster.DE$cluster)

cluster.DE.GObp <- cluster.DE.l %>% lapply(FUN = function(x){
  x <- x %>% left_join(entrez_dbi_map)
  
  selectUp <- (x %>% filter(p_val < 0.001, avg_log2FC > 0.5))$entrezid
  
  print(paste("Number of genes:" , length(selectUp)))
  
  upParams <- new("GOHyperGParams", 
                geneIds = selectUp, 
                universeGeneIds = unique(cluster.DE$entrezid), 
                annotation = "org.Hs.eg.db", 
                ontology = "BP", 
                pvalueCutoff = 0.01,
                conditional = FALSE, testDirection = "over"
                )
  
  x <- hyperGTest(upParams)
})

cluster.DE.GObp %>% lapply(summary)

# Combine summaries from the GO enrichment tests
cluster.DE.GObp_summary <- cluster.DE.GObp[[1]] %>% summary() %>% mutate(cluster = 0) %>% filter(Pvalue == "nothing")

for(i in 1:length(cluster.DE.GObp)){
  print(i)
  cluster.DE.GObp_summary <- rbind(
    cluster.DE.GObp_summary, 
    cluster.DE.GObp[[i]] %>% summary() %>% mutate(cluster = i-1)
    )
}


if(export){
cluster.DE.GObp_summary %>% write.csv2("data/scRNA_cluster_GObp.csv", row.names = FALSE)
}

cluster.DE.GObp_summary <- read.csv2("data/scRNA_cluster_GObp.csv")
cluster.DE.GObp_summary %>% split(cluster.DE.GObp_summary$cluster)
```

# Regress cell cycle scores during data scaling

```{r}
median_library_size <- scRNA_c@assays$RNA %>% colSums() %>% median()

# Normalize dataset
scRNA_regcycle <- NormalizeData(scRNA_c, normalization.method = "LogNormalize", scale.factor = median_library_size)

# find highly variable features with a variance stabilizing transform
scRNA_regcycle <- FindVariableFeatures(scRNA_regcycle, selection.method = "vst", nfeatures = 2000)

VariableFeaturePlot(scRNA_regcycle) %>% LabelPoints(points = head(VariableFeatures(scRNA_regcycle), 30), repel = TRUE)

# Assign and inspect cell cycle scores
scRNA_regcycle <- CellCycleScoring(scRNA_regcycle, s.features = s.genes, g2m.features = g2m.genes)

# Scale dataset
vars_to_regress <- c("S.Score", "G2M.Score")

scRNA_regcycle <- ScaleData(scRNA_regcycle, 
                    vars.to.regress = vars_to_regress)

# Another option is regressing the difference between S and G2M scores. Differences between G1 and proliferating cells would be mantained, but S and G2M cells tend to be mixed
# scRNA_regcycle$CC.Difference <- scRNA_regcycle$S.Score - scRNA_regcycle$G2M.Score
# scRNA_regcycle <- ScaleData(scRNA_regcycle, vars.to.regress = "CC.Difference", features = rownames(scRNA_regcycle))


# Add CIN status meta data
scRNA_regcycle@meta.data <- scRNA_regcycle@meta.data %>% mutate(CIN_status = ifelse(orig.ident %in% c("dnMCAK"),"CIN-high","CIN-low"))

```

## Perform PCA
```{r}
# Perform PCA
scRNA_regcycle <- RunPCA(scRNA_regcycle, features = VariableFeatures(object = scRNA_regcycle), npcs = 200)

# Plot PCA results
Idents(scRNA_regcycle) <- "orig.ident"
VizDimLoadings(scRNA_regcycle, dims = 1:2, reduction = "pca")
DimPlot(scRNA_regcycle, reduction = "pca")
ElbowPlot(scRNA_regcycle, ndims = 200)

DimHeatmap(scRNA_regcycle, dims = 1:10, cells = 500, balanced = TRUE)

# Check the total variance explained
# On Seurat 3:
pca <- scRNA_regcycle[["pca"]]
# Get the total variance of the scaled counts matrix:
mat <- Seurat::GetAssayData(scRNA_regcycle, assay = "RNA", slot = "scale.data")
mat <- mat[rownames(mat) %in% VariableFeatures(scRNA_regcycle), ]

total_variance <- sum(matrixStats::rowVars(mat))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance

varExplained

cumsum(varExplained) %>% as.data.frame() %>% rename("cumvar" = ".") %>% ggplot(aes(x = c(1:200), y = cumvar)) + geom_point() + labs(x = "PC #", y = "Cumulative Variance")

rm(mat)
rm(pca)

```

```{r}
# Compute a null distribution for feature scores by permuting 1% of the data multiple times and compare this with information within each PC to obtain a significance estimate
scRNA_regcycle <- JackStraw(scRNA_regcycle, num.replicate = 100, dims = 50)
scRNA_regcycle <- ScoreJackStraw(scRNA_regcycle, dims = 1:50)
JackStrawPlot(scRNA_regcycle, dims = 1:50)
# 1:50
```

```{r}
Idents(scRNA_regcycle) <- "Phase"
RidgePlot(scRNA_regcycle, features = c("PCNA", "TOP2A", "MCM6", "MKI67"), ncol = 2)
Idents(scRNA_regcycle) <- "orig.ident"
RidgePlot(scRNA_regcycle, features = c("PCNA", "TOP2A", "MCM6", "MKI67"), ncol = 2)
```

## Run UMAP and TSNE
```{r}
# This is not using the cell cycle regressed data! the visualization looks the same as before

# Dimensionality reduction with UMAP on variable features instead of PCs
scRNA_regcycle <- RunUMAP(scRNA_regcycle, reduction.use = NULL, features = VariableFeatures(scRNA_regcycle))

# Store this UMAP as a custom reduction
scRNA_regcycle[["UMAP_features"]] <- CreateDimReducObject(embeddings = scRNA_regcycle@reductions$umap@cell.embeddings, key = "UMAP_features", assay = DefaultAssay(scRNA_regcycle))

# Run UMAP and project in 3D dimensions
scRNA_regcycle <- RunUMAP(scRNA_regcycle, dims = 1:200, n.components = 3L)

# Store this UMAP as a custom reduction
scRNA_regcycle[["umap3d"]] <- CreateDimReducObject(embeddings = scRNA_regcycle@reductions$umap@cell.embeddings, key = "umap3d", assay = DefaultAssay(scRNA_regcycle))


# PCs seem to be using the regressed data as intended

# Dimensionality reduction with UMAP and tSNE on PCs
scRNA_regcycle <- RunUMAP(scRNA_regcycle, dims = 1:200)

scRNA_regcycle <- RunTSNE(scRNA_regcycle, dims.use = 1:200, reduction.use = "pca", perplexity = 30)

```

## Clustering cells
```{r}
# Clustering cells
scRNA_regcycle <- FindNeighbors(scRNA_regcycle, dims = 1:200)
scRNA_regcycle <- FindClusters(scRNA_regcycle, resolution = 0.5)

scRNA_regcycle <- StashIdent(scRNA_regcycle, save.name = "clusterID")

# Inspect cluster information
#head(Idents(scRNA_cn), 5)
Idents(scRNA_regcycle) <- "clusterID"

prop.table(table(scRNA_regcycle$CIN_status))

table(scRNA_regcycle$orig.ident)
table(scRNA_regcycle$clusterID)
prop.table(table(scRNA_regcycle$clusterID))
prop.table(table(scRNA_regcycle$clusterID, scRNA_regcycle$orig.ident), margin = 2)
prop.table(table(scRNA_regcycle$orig.ident, scRNA_regcycle$clusterID), margin = 2)

prop.table(table(scRNA_regcycle$clusterID, scRNA_regcycle$CIN_status), margin = 2)
prop.table(table(scRNA_regcycle$CIN_status, scRNA_regcycle$clusterID), margin = 2)

table(scRNA_regcycle$clusterID, scRNA_regcycle$CIN_status) %>% as.data.frame() %>% rename("clusterID" = Var1, "group" = Var2) %>% ggplot(aes(x = clusterID, y = group, fill = Freq)) + geom_tile() + scale_fill_distiller(palette = "PuBu") + geom_text(aes(label=Freq)) + labs(y = "", fill = "Number of cells")

```

```{r}
prop.table(table(scRNA_regcycle$Phase, scRNA_regcycle$clusterID), margin = 2)

prop.table(table(scRNA_regcycle$CIN_status, scRNA_regcycle$clusterID), margin = 2)

cluster_assignment <- prop.table(table(scRNA_regcycle$CIN_status, scRNA_regcycle$clusterID), margin = 2) %>% as.data.frame() %>% rename("CIN_status" = Var1, "cluster" = Var2)

cluster_assignment$CIN_status <- gsub("-", "_", cluster_assignment$CIN_status)

cluster_assignment <- cluster_assignment %>% pivot_wider(values_from = Freq, names_from = CIN_status) %>% mutate(CIN_status = ifelse(CIN_high < 0.15, "CIN-low", "CIN-high"))

cluster_assignment
```
## Visualization
```{r}
# DimPlot(scRNA_regcycle, reduction = "UMAP_features", group.by = "CIN_status")
# DimPlot(scRNA_regcycle, reduction = "UMAP_features", group.by = "orig.ident")
# DimPlot(scRNA_regcycle, reduction = "UMAP_features", group.by = "Phase")
# DimPlot(scRNA_regcycle, reduction = "UMAP_features", group.by = "clusterID")

DimPlot(scRNA_regcycle, reduction = "umap", group.by = "CIN_status")
DimPlot(scRNA_regcycle, reduction = "umap", group.by = "orig.ident")
DimPlot(scRNA_regcycle, reduction = "umap", group.by = "Phase")
DimPlot(scRNA_regcycle, reduction = "umap", group.by = "clusterID")

DimPlot(scRNA_regcycle, reduction = "tsne", group.by = "CIN_status")
DimPlot(scRNA_regcycle, reduction = "tsne", group.by = "orig.ident")
DimPlot(scRNA_regcycle, reduction = "tsne", group.by = "Phase")
DimPlot(scRNA_regcycle, reduction = "tsne", group.by = "clusterID")

```

## 3D UMAP
```{r}
# Visualize what headings are called so that you can extract them to form a dataframe
Embeddings(object = scRNA_regcycle, reduction = "umap3d") %>% head()

# Prepare a dataframe for cell plotting
plot.data <- FetchData(object = scRNA_regcycle, vars = c("umap3d_1", "umap3d_2", "umap3d_3", "seurat_clusters", "Phase", "orig.ident"))

# Make a column of row name identities (these will be your cell/barcode names)
plot.data$label <- paste(rownames(plot.data))

# Plot your data
#When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

fig <- plot_ly(data = plot.data, 
        x = ~umap3d_1, y = ~umap3d_2, z = ~umap3d_3, 
        color = ~seurat_clusters, 
        colors = c("lightseagreen", "gray50", "darkgreen", "red4", "red", "turquoise4",
                   "black", "yellow4", "royalblue1", "lightcyan3", "peachpuff3",
                   "khaki3", "gray20", "orange2", "royalblue4", "yellow3", "gray80",
                   "darkorchid1", "lawngreen", "plum2", "darkmagenta"),
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 3, width=2), # controls size of points
        text=~orig.ident,
        hoverinfo="text") 
fig

fig <- plot_ly(data = plot.data, 
        x = ~umap3d_1, y = ~umap3d_2, z = ~umap3d_3, 
        color = ~Phase,
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 3, width=2), # controls size of points
        text=~orig.ident,
        hoverinfo="text") 

fig

# Before you plot, set the ranges of the axis you desire. This set axis range will be 
# present across all clusters, and plotly will not adjust for axis length anymore
# this axis length will persist even when selecting some clusters

# xaxis
# axx <- list(nticks = 4,  range = c(-10,10))

# yaxis
# axy <- list(nticks = 4, range = c(-10,10))

#zaxis
# axz <- list(nticks = 4, range = c(-10,10))


# fig <- fig %>% layout(scene = list(xaxis=axx,yaxis=axy,zaxis=axz))
# fig_cube <- fig %>% layout(scene = list(xaxis=axx,yaxis=axy,zaxis=axz, aspectmode='cube')) # To maintain cubic aspect

rm(plot.data)

```


```{r}
# Say you wanto make a gene-expression 3D plot, where you can plot gene expression against a color scale
# Here using the same seurat object as above, we extract gene expression information for beta-actin 'ACTB'
# Here we concentrate on SCT normalized data, or log normalized RNA NOT raw counts.
# In addition if you want, you may look at normalised-RNA, SCT or integrated slots, to look at gene expression
# Setting your DefaultAssay() will inform R which assay to pick up expression data from.

# DefaultAssay(object = yourseuratobject)
# DefaultAssay(object = yourseuratobject) <- "RNA"
# DefaultAssay(object = yourseuratobject) <- "integrated"
# DefaultAssay(object = yourseuratobject) <- "SCT"

# create a dataframe
# plot.data <- FetchData(object = yourseuratobject, vars = c("UMAP_1", "UMAP_2", "UMAP_3", "ACTB"), slot = 'data')

# Say you want change the scale, so that every cell having an expression >1 will be one color
# Basically, you are re-adjusting the scale here, so that any cell having a certain expression will light up on your 3D plot

# First make another column in your dataframe, where all values above 1 are re-assigned a value of 1
# This information is stored in the 'changed' column of your dataframe

# plot.data$changed <- ifelse(test = plot.data$ACTB <1, yes = plot.data$ACTB, no = 1)

# Add the label column, so that now the column has 'cellname-its expression value'

# plot.data$label <- paste(rownames(plot.data)," - ", plot.data$ACTB, sep="")

# Plot your data, in this example my Seurat object had 21 clusters (0-20), and cells express a gene called ACTB

# you can just run this against the column for the gene as well using ~ACTB, the algorith will automatically scale in that case based on maximal and minimal values
# plot_ly(data = plot.data, 
#         x = ~UMAP_1, y = ~UMAP_2, z = ~UMAP_3, 
#         color = ~changed, 
#         opacity = .5,
#         colors = c('darkgreen', 'red'), 
#         type = "scatter3d", 
#         mode = "markers",
#         marker = list(size = 5, width=2), 
#         text=~label,
#         hoverinfo="text"
# )

# On running this code the HTML output should appear in RStudio. You can save the output as a
# HTML file. Once you have saved, just open the HTML file in any web browser (double click on the html- file
# and if asked select to open with any web browser like google chrome/safari/mozilla/explorer etc).
# It should be have all of the integrated features you saw in the RStudio output file.
```

## Cluster markers
```{r}
# Find cluster markers 
Idents(scRNA_regcycle) <- "clusterID"
cellreg.cluster.DE <- FindAllMarkers(scRNA_regcycle, min.pct = 0.05, logfc.threshold = 0)

#cluster.markers
clustertop10 <- cellreg.cluster.DE %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)

cellreg.cluster.DE %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)

```

## Plotting signatures
```{r}
Idents(scRNA_regcycle) <- "clusterID"

# Plotting EMT signature 
EMT_signature <- c("VIM", "ZEB2", "SNAI2", "ZEB1")

VlnPlot(scRNA_regcycle, features = EMT_signature)
FeaturePlot(scRNA_regcycle, features = EMT_signature)

EMT_signature2 <- c("EZH", "JUN", "VIM", "STEAP1", "SOX4", "MMP14", "SHH", "TIMP1", "ZEB1")

EMT_signature2 <- EMT_signature2[EMT_signature2 %in% rownames(scRNA_regcycle@assays$RNA)]

Idents(scRNA_regcycle) <- "clusterID"
for(i in 1:length(EMT_signature2)){
p <- VlnPlot(scRNA_regcycle, features = EMT_signature2[i])
print(p)
}

```
```{r}
# Plotting Genes enriched in the "M" Population from Bakhoum et al
M_markers = c("ITGB5", "ITGB1", "ITGA5", "ITGA10", "IGFBP4", "FN1", "DSC2", "CXCL1","CTNNB1", "BMP4", "BCL2L1")

Idents(scRNA_regcycle) <- "clusterID"
for(i in 1:length(M_markers)){
p <- VlnPlot(scRNA_regcycle, features = M_markers[i])
print(p)
p <- FeaturePlot(scRNA_regcycle, features = M_markers[i])
print(p)
}
```

```{r}
# Plot CIN signature from Bakhoum et al 2018 (Supp. table 5), comparing CIN high and CIN low
CIN_signature <- c('PELI2','BMP2','SHH','TNS4','RAB3B','ROBO1','ARHGAP28','CHN2','CST1','F13A1','CPVL','SEMA6D','NHSL2','GTF2IP7','DPYSL3','PCDH7','KHDRBS3','TRAC','TMEM156',
'CST4','CD24','FGF5','NTN4')

CIN_present <- CIN_signature %in% rownames(scRNA_regcycle@assays$RNA)

Idents(scRNA_regcycle) <- "clusterID"
for(i in 1:length(CIN_present)){
p <- VlnPlot(scRNA_regcycle, features = CIN_signature[CIN_present][i])
print(p)
}

```

## CIN DE
```{r}
# Plot gene expression of CIN high x low cells
Idents(scRNA_regcycle) <- "CIN_status"

# Subset data
CIN_high <- subset(scRNA_regcycle, idents = "CIN-high")
CIN_low <- subset(scRNA_regcycle, idents = "CIN-low")

# Calculate average gene expression for CIN high and low cells
avg.CINhigh.cells <- as.data.frame(AverageExpression(CIN_high, verbose = FALSE)$RNA) %>% rename("CIN_high" = all) %>% rownames_to_column("gene")

avg.CINlow.cells <- as.data.frame(AverageExpression(CIN_low, verbose = FALSE)$RNA) %>% rename("CIN_low" = all) %>% rownames_to_column("gene")


# Plot CIN high x cin low pseudocounts in log space
avg.CINhigh.cells %>% full_join(avg.CINlow.cells, by = "gene") %>% ggplot(aes(x = CIN_low, y = CIN_high)) + geom_point() + scale_y_continuous(trans = "log1p") + scale_x_continuous(trans = "log1p")

# avg.CINhigh.cells %>% full_join(avg.CINlow.cells, by = "gene") %>% mutate(fc = (CIN_high + 1)/(CIN_low + 1), log2fc = log2(fc)) %>% filter(gene %in% c("LAPTM5", "MARCKSL1", "HLA-B"))

```

```{r}
# Find CIN-high markers based on DE 
Idents(scRNA_regcycle) <- "CIN_status"

# This is doing the same as CIN.DE from before, it´s not using the cell cycle regression
cellreg.CIN.DE <- FindMarkers(scRNA_regcycle, ident.1 = "CIN-high", ident.2 = "CIN-low", min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")

CIN.top <- cellreg.CIN.DE %>% top_n(n = 25, wt = avg_log2FC)

DoHeatmap(scRNA_regcycle, features = CIN.top$gene)
```

```{r}
# Compare with Bakhoum CIN gene signature
CIN_signature_df <- CIN_signature %>% as.data.frame() %>% rename('gene' = ".") %>% mutate(Bakhoum_gene_sig = TRUE)

cellreg.CIN.DE %>% left_join(CIN_signature_df) %>% filter(Bakhoum_gene_sig)
#CIN.cluster.markers %>% filter(str_detect(gene, "BMP2"))
```
## FGSEA DE between clusters
```{r}
cellreg.cluster.DE.l <- cellreg.cluster.DE %>% select(gene, cluster, avg_log2FC) %>% split(f = cellreg.cluster.DE$cluster)

cellreg.cluster.DE.fgsea <- cellreg.cluster.DE.l %>% lapply(FUN = function(x){
  x <- x %>% select(-cluster) %>% deframe()
  x <- fgsea(pathways = msigdb_hallmarks_set, 
                  stats = x,
                  minSize = 15,
                  maxSize = 500)
})


# Plot results for the GSEA on each cluster 
lapply(seq_along(cellreg.cluster.DE.fgsea), FUN = function(i){
  cellreg.cluster.DE.fgsea[[i]] <- cellreg.cluster.DE.fgsea[[i]] %>% mutate(
    within_threshold = pval < 0.05, 
    pval = ifelse(pval < 0.0001, 0.000101, pval)
    ) %>% left_join(msigdb_hallmarks_names)

  cellreg.cluster.DE.fgsea[[i]] %>% ggplot(aes(x = log10(pval), y = NES)) +
  geom_point(aes(size = 0.5, alpha = 0.3, col = as.factor(sign(NES)))) + 
  geom_hline(yintercept = 0, col = "black") +
  geom_text_repel(
  aes(x = log10(pval), y = NES, label = name), data = cellreg.cluster.DE.fgsea[[i]] %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
  ) +
  labs(x = "log10(pval)", y = "Normalized Enrichment Score", col = "Enriched in Cluster", title = paste("Cluster: ", i - 1, sep = "")) + 
  scale_y_continuous(limits = c(-3,3), breaks = seq(-3,3,1)) + 
  scale_x_continuous(trans = "reverse", limits = c(0, -4), breaks = c(-4, -3, -2, -1, 0) , labels = c("<0.0001", "0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)
})


# Combine summaries from the GO enrichment tests
cellreg.cluster.DE.fgsea_summary <- cellreg.cluster.DE.fgsea[[1]] %>% mutate(cluster = 0) %>% filter(pval == "nothing")

for(i in 1:length(cellreg.cluster.DE.fgsea)){
  print(i)
  cellreg.cluster.DE.fgsea_summary <- rbind(
    cellreg.cluster.DE.fgsea_summary, 
    cellreg.cluster.DE.fgsea[[i]] %>% mutate(cluster = i-1)
    )
}

if(export){
cellreg.cluster.DE.fgsea_summary %>% select(-leadingEdge) %>% write.csv2("data/scRNA_cellreg_cluster_fgsea.csv", row.names = FALSE)
}

cellreg.cluster.DE.fgsea_summary <- read.csv2("data/scRNA_cellreg_cluster_fgsea.csv")
cellreg.cluster.DE.fgsea <- cluster.DE.fgsea_summary %>% split(f = cluster.DE.fgsea_summary$cluster)


```

## Heatmap Cluster NES
```{r}
colfunc <- colorRampPalette(c("blue", "white", "red"))

cellreg.cluster.DE.fgsea_summary %>% left_join(msigdb_hallmarks_names) %>% select(name, NES, cluster) %>% pivot_wider(values_from = NES, names_from = name) %>% column_to_rownames("cluster") %>% mutate_all(~replace(., is.na(.), 0)) %>% as.matrix() %>% pheatmap(col=colfunc(10))

cellreg.cluster.DE.fgsea_summary %>% left_join(msigdb_hallmarks_names) %>% select(name, NES, cluster) %>% pivot_wider(values_from = NES, names_from = name)  %>% 
  column_to_rownames(var = "cluster") %>% mutate_all(~replace(., is.na(.), 0)) %>% as.matrix() %>%
  heatmap.2(col=colfunc(10), dendrogram = "both", trace = "none", srtCol=75)

```

## Specific Cluster comparisons 
```{r}
cellreg.cluster.DE.fgsea %>% lapply(function(x){
  x %>% arrange(-NES)
})

# Find cluster markers 
Idents(scRNA_regcycle) <- "clusterID"

cellreg.cluster.DE13 <- FindMarkers(scRNA_regcycle, ident.1 = 1, ident.2 = 3, min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene") %>% mutate(cluster = "13")
cellreg.cluster.DE13 %>% write.csv2("data/scRNA_cellreg_cluster13.csv", row.names = FALSE)
cellreg.cluster.DE13 <- read.csv2("data/scRNA_cellreg_cluster13.csv")

cellreg.cluster.DE04 <- FindMarkers(scRNA_regcycle, ident.1 = 0, ident.2 = 4, min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")  %>% mutate(cluster = "04")
cellreg.cluster.DE04 %>% write.csv2("data/scRNA_cellreg_cluster04.csv", row.names = FALSE)
cellreg.cluster.DE04 <- read.csv2("data/scRNA_cellreg_cluster04.csv")

cellreg.cluster.DE56 <- FindMarkers(scRNA_regcycle, ident.1 = 5, ident.2 = 6, min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")  %>% mutate(cluster = "56")
cellreg.cluster.DE56 %>% write.csv2("data/scRNA_cellreg_cluster56.csv", row.names = FALSE)
cellreg.cluster.DE56 <- read.csv2("data/scRNA_cellreg_cluster56.csv")

cellreg.cluster.DE52 <- FindMarkers(scRNA_regcycle, ident.1 = 5, ident.2 = 2, min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")  %>% mutate(cluster = "52")
cellreg.cluster.DE52 %>% write.csv2("data/scRNA_cellreg_cluster52.csv", row.names = FALSE)
cellreg.cluster.DE52 <- read.csv2("data/scRNA_cellreg_cluster52.csv")

cellreg.cluster.DE62 <- FindMarkers(scRNA_regcycle, ident.1 = 6, ident.2 = 2, min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")  %>% mutate(cluster = "62")
cellreg.cluster.DE62 %>% write.csv2("data/scRNA_cellreg_cluster62.csv", row.names = FALSE)
cellreg.cluster.DE62 <- read.csv2("data/scRNA_cellreg_cluster62.csv")

cellreg.cluster.DE62 <- FindMarkers(scRNA_regcycle, ident.1 = 6, ident.2 = 2, min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")  %>% mutate(cluster = "62")
cellreg.cluster.DE62 %>% write.csv2("data/scRNA_cellreg_cluster62.csv", row.names = FALSE)

cellreg.cluster.DE10 <- FindMarkers(scRNA_regcycle, ident.1 = 1, ident.2 = 0, min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")  %>% mutate(cluster = "10")
cellreg.cluster.DE10 %>% write.csv2("data/scRNA_cellreg_cluster10.csv", row.names = FALSE)

cellreg.cluster.DE14 <- FindMarkers(scRNA_regcycle, ident.1 = 1, ident.2 = 4, min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")  %>% mutate(cluster = "14")
cellreg.cluster.DE14 %>% write.csv2("data/scRNA_cellreg_cluster14.csv", row.names = FALSE)

cellreg.cluster.DE30 <- FindMarkers(scRNA_regcycle, ident.1 = 3, ident.2 = 0, min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")  %>% mutate(cluster = "30")
cellreg.cluster.DE30 %>% write.csv2("data/scRNA_cellreg_cluster30.csv", row.names = FALSE)

cellreg.cluster.DE34 <- FindMarkers(scRNA_regcycle, ident.1 = 3, ident.2 = 4, min.pct = 0.05, logfc.threshold = 0) %>% rownames_to_column("gene")  %>% mutate(cluster = "34")
cellreg.cluster.DE34 %>% write.csv2("data/scRNA_cellreg_cluster34.csv", row.names = FALSE)


cellreg.specific.clusters <- rbind(cellreg.cluster.DE13, cellreg.cluster.DE04, cellreg.cluster.DE56, cellreg.cluster.DE52, cellreg.cluster.DE62, cellreg.cluster.DE10, cellreg.cluster.DE14, cellreg.cluster.DE30, cellreg.cluster.DE34)

```

```{r}
rm(cellreg.cluster.DE13)
rm(cellreg.cluster.DE04)
rm(cellreg.cluster.DE56)
rm(cellreg.cluster.DE52)
rm(cellreg.cluster.DE62)
rm(cellreg.cluster.DE10)
rm(cellreg.cluster.DE14)
rm(cellreg.cluster.DE30)
rm(cellreg.cluster.DE34)

```

## FGSEA between specific clusters
```{r}
cellreg.specific.clusters.l <- cellreg.specific.clusters %>% select(gene, cluster, avg_log2FC) %>% split(f = cellreg.specific.clusters$cluster)

cellreg.specific.clusters.fgsea <- cellreg.specific.clusters.l %>% lapply(FUN = function(x){
  x <- x %>% select(-cluster) %>% deframe()
  x <- fgsea(pathways = msigdb_hallmarks_set, 
                  stats = x,
                  minSize = 15,
                  maxSize = 500)
})


# Plot results for the GSEA on each cluster 
lapply(seq_along(cellreg.specific.clusters.fgsea), FUN = function(i){
  cellreg.specific.clusters.fgsea[[i]] <- cellreg.specific.clusters.fgsea[[i]] %>% mutate(
    within_threshold = pval < 0.05, 
    pval = ifelse(pval < 0.0001, 0.000101, pval)
    ) %>% left_join(msigdb_hallmarks_names)

  cellreg.specific.clusters.fgsea[[i]] %>% ggplot(aes(x = log10(pval), y = NES)) +
  geom_point(aes(size = 0.5, alpha = 0.3, col = as.factor(sign(NES)))) + 
  geom_hline(yintercept = 0, col = "black") +
  geom_text_repel(
  aes(x = log10(pval), y = NES, label = name), data = cellreg.specific.clusters.fgsea[[i]] %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
  ) +
  labs(x = "log10(pval)", y = "Normalized Enrichment Score", col = "Enriched in Cluster", title = paste("Cluster: ", names(cellreg.specific.clusters.fgsea)[[i]], sep = "")) + 
  scale_y_continuous(limits = c(-3,3), breaks = seq(-3,3,1)) + 
  scale_x_continuous(trans = "reverse", limits = c(0, -4), breaks = c(-4, -3, -2, -1, 0) , labels = c("<0.0001", "0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)
})

# Combine summaries from the GO enrichment tests
cellreg.specific.clusters.fgsea_summary <- cellreg.specific.clusters.fgsea[[1]] %>% mutate(cluster = 0) %>% filter(pval == "nothing")

for(i in 1:length(cellreg.specific.clusters.fgsea)){
  print(i)
  cellreg.specific.clusters.fgsea_summary <- rbind(
    cellreg.specific.clusters.fgsea_summary, 
    cellreg.specific.clusters.fgsea[[i]] %>% mutate(cluster = names(cellreg.specific.clusters.fgsea)[[i]])
    )
}

if(export){
cellreg.specific.clusters.fgsea_summary %>% select(-leadingEdge) %>% write.csv2("data/scRNA_cellreg_specific_cluster_fgsea.csv", row.names = FALSE)
}

cellreg.specific.clusters.fgsea_summary <- read.csv2("data/scRNA_cellreg_specific_cluster_fgsea.csv")

cellreg.specific.clusters.fgsea <- cellreg.specific.clusters.fgsea_summary %>% split(f = cluster.DE.fgsea_summary$cluster)


```

```{r}
DimPlot(scRNA_regcycle, reduction = "umap", group.by = "CIN_status")
DimPlot(scRNA_regcycle, reduction = "umap", group.by = "orig.ident")
DimPlot(scRNA_regcycle, reduction = "umap", group.by = "Phase")
DimPlot(scRNA_regcycle, reduction = "umap", group.by = "clusterID")

```

## Entrez ID symbol Mapping
```{r}
# Map symbols to entrezids using Annotation dbi
entrez_dbi_map <- cellreg.cluster.DE %>% select(gene) %>% unique()

entrez_dbi_map$entrezid <- mapIds(org.Hs.eg.db,
                    keys=entrez_dbi_map$gene,
                    column="ENTREZID",
                    keytype="SYMBOL",
                    multiVals="first")

entrez_dbi_map %>% filter(is.na(entrezid)) %>% n_distinct() 
entrez_dbi_map %>% filter(!is.na(entrezid)) %>% n_distinct()

entrez_dbi_map %>% filter(is.na(entrezid)) %>% n_distinct() + 
entrez_dbi_map %>% filter(!is.na(entrezid)) %>% n_distinct()

```

## GO BP Enrichment
```{r}
cellreg.cluster.DE.l <- cellreg.cluster.DE %>% select(gene, p_val, cluster, avg_log2FC) %>% split(f = cellreg.cluster.DE$cluster)

cellreg.cluster.DE.GObp <- cellreg.cluster.DE.l %>% lapply(FUN = function(x){
  x <- x %>% left_join(entrez_dbi_map)
  
  selectUp <- (x %>% filter(p_val < 0.001, avg_log2FC > 0.5))$entrezid
  
  print(paste("Number of genes:" , length(selectUp)))
  
  upParams <- new("GOHyperGParams", 
                geneIds = selectUp, 
                universeGeneIds = unique(cellreg.cluster.DE$entrezid), 
                annotation = "org.Hs.eg.db", 
                ontology = "BP", 
                pvalueCutoff = 0.01,
                conditional = FALSE, testDirection = "over"
                )
  
  x <- hyperGTest(upParams)
})

cellreg.cluster.DE.GObp %>% lapply(summary)

# Combine summaries from the GO enrichment tests
cellreg.cluster.DE.GObp_summary <- cellreg.cluster.DE.GObp[[1]] %>% summary() %>% mutate(cluster = 0) %>% filter(Pvalue == "nothing")

for(i in 1:length(cellreg.cluster.DE.GObp)){
  print(i)
  cellreg.cluster.DE.GObp_summary <- rbind(
    cellreg.cluster.DE.GObp_summary, 
    cellreg.cluster.DE.GObp[[i]] %>% summary() %>% mutate(cluster = i-1)
    )
}


if(export){
cellreg.cluster.DE.GObp_summary %>% write.csv2("data/scRNA_cellreg_cluster_GObp.csv", row.names = FALSE)
}

cluster.DE.GObp_summary <- read.csv2("data/scRNA_cellreg_cluster_GObp.csv")
cluster.DE.GObp_summary %>% split(cluster.DE.GObp_summary$cluster)
```



## Export
```{r}
if(export){
saveRDS(scRNA_regcycle, file = "data/Bakhoum_scRNA_cellreg.rds")
  
cellreg.cluster.DE %>% write.csv2("data/Bakhoum_scRNA_cellreg_cluster_markers.csv", row.names = FALSE)

cellreg.CIN.DE %>% write.csv2("data/Bakhoum_scRNA_cellreg_CIN_cluster_markers.csv", row.names = FALSE)

# Export data for pre ranked GSEA
# Convert p-values of zero to 1e-300, then calculate the preranking statistic and export
cellreg.CIN.DE %>% mutate(
  p_val = ifelse(p_val == 0, 1e-300, p_val),
  signlogFC_pval = sign(avg_log2FC) * -log10(p_val)
  ) %>% select(gene, signlogFC_pval) %>% rename("NAME" = gene) %>% write.table("data/Bakhoum_scRNA_cellreg_CIN_Highlow_GSEA_pval.rnk", sep = "\t", row.names = FALSE, quote = FALSE)

cellreg.CIN.DE %>% select(gene, avg_log2FC) %>% rename("NAME" = gene) %>% write.table("data/Bakhoum_scRNA_cellreg_CIN_Highlow_GSEA_fc.rnk", sep = "\t", row.names = FALSE, quote = FALSE)

}

scRNA_regcycle <- readRDS(file = "data/Bakhoum_scRNA_cellreg.rds")
cellreg.cluster.DE <- read.csv2("data/Bakhoum_scRNA_cellreg_cluster_markers.csv")
cellreg.CIN.DE <- read.csv2("data/Bakhoum_scRNA_cellreg_CIN_cluster_markers.csv")

```

# Using SCTransform

```{r}
scRNA_SCT <- SCTransform(scRNA_c, verbose = FALSE)

# Add CIN status meta data
scRNA_SCT@meta.data <- scRNA_SCT@meta.data %>% mutate(CIN_status = ifelse(orig.ident %in% c("dnMCAK"),"CIN-high","CIN-low"))

# Score cell cycle
scRNA_SCT <- CellCycleScoring(scRNA_SCT, s.features = s.genes, g2m.features = g2m.genes)

```

## Perform PCA
```{r}
# Perform PCA
scRNA_SCT <- RunPCA(scRNA_SCT, npcs = 200)

# Plot PCA results
Idents(scRNA_SCT) <- "orig.ident"
VizDimLoadings(scRNA_SCT, dims = 1:2, reduction = "pca")
DimPlot(scRNA_SCT, reduction = "pca")
ElbowPlot(scRNA_SCT, ndims = 200)

# Check the total variance explained
# On Seurat 3:
pca <- scRNA_SCT[["pca"]]
# Get the total variance of the scaled counts matrix:
mat <- Seurat::GetAssayData(scRNA_SCT, assay = "SCT", slot = "scale.data")

total_variance <- sum(matrixStats::rowVars(mat))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance

varExplained

cumsum(varExplained) %>% as.data.frame() %>% rename("cumvar" = ".") %>% ggplot(aes(x = c(1:200), y = cumvar)) + geom_point() + labs(x = "PC #", y = "Cumulative Variance")

rm(mat)
rm(pca)

```

## Run UMAP and TSNE
```{r}
# This is not using the cell cycle regressed data! the visualization looks the same as before

# Dimensionality reduction with UMAP on variable features instead of PCs
scRNA_SCT <- RunUMAP(scRNA_SCT, reduction.use = NULL, features = VariableFeatures(scRNA_SCT))

# Store this UMAP as a custom reduction
scRNA_SCT[["UMAP_features"]] <- CreateDimReducObject(embeddings = scRNA_SCT@reductions$umap@cell.embeddings, key = "UMAP_features", assay = DefaultAssay(scRNA_SCT))

# Run UMAP and project in 3D dimensions
scRNA_SCT <- RunUMAP(scRNA_SCT, dims = 1:200, n.components = 3L)

# Store this UMAP as a custom reduction
scRNA_SCT[["umap3d"]] <- CreateDimReducObject(embeddings = scRNA_SCT@reductions$umap@cell.embeddings, key = "umap3d", assay = DefaultAssay(scRNA_SCT))


# PCs seem to be using the regressed data as intended

# Dimensionality reduction with UMAP on PCs
scRNA_SCT <- RunUMAP(scRNA_SCT, dims = 1:200)

```

## Clustering cells
```{r}
# Clustering cells
scRNA_SCT <- FindNeighbors(scRNA_SCT, dims = 1:200)
scRNA_SCT <- FindClusters(scRNA_SCT, resolution = 0.5)

scRNA_SCT <- StashIdent(scRNA_SCT, save.name = "clusterID")

# Inspect cluster information
#head(Idents(scRNA_cn), 5)
Idents(scRNA_SCT) <- "clusterID"

table(scRNA_SCT$clusterID)
prop.table(table(scRNA_SCT$clusterID))
prop.table(table(scRNA_SCT$clusterID, scRNA_SCT$orig.ident), margin = 2)
prop.table(table(scRNA_SCT$orig.ident, scRNA_SCT$clusterID), margin = 2)

prop.table(table(scRNA_SCT$clusterID, scRNA_SCT$CIN_status), margin = 2)
prop.table(table(scRNA_SCT$CIN_status, scRNA_SCT$clusterID), margin = 2)

table(scRNA_SCT$clusterID, scRNA_SCT$CIN_status) %>% as.data.frame() %>% rename("clusterID" = Var1, "group" = Var2) %>% ggplot(aes(x = clusterID, y = group, fill = Freq)) + geom_tile() + scale_fill_distiller(palette = "PuBu") + geom_text(aes(label=Freq)) + labs(y = "", fill = "Number of cells")

```
## Visualization
```{r}
DimPlot(scRNA_SCT, reduction = "UMAP_features", group.by = "CIN_status")
DimPlot(scRNA_SCT, reduction = "UMAP_features", group.by = "orig.ident")
DimPlot(scRNA_SCT, reduction = "UMAP_features", group.by = "Phase")
DimPlot(scRNA_SCT, reduction = "UMAP_features", group.by = "clusterID")

DimPlot(scRNA_SCT, reduction = "umap", group.by = "CIN_status")
DimPlot(scRNA_SCT, reduction = "umap", group.by = "orig.ident")
DimPlot(scRNA_SCT, reduction = "umap", group.by = "Phase")
DimPlot(scRNA_SCT, reduction = "umap", group.by = "clusterID")

```

## 3D UMAP
```{r}
# Visualize what headings are called so that you can extract them to form a dataframe
Embeddings(object = scRNA_SCT, reduction = "umap3d") %>% head()

# Prepare a dataframe for cell plotting
plot.data <- FetchData(object = scRNA_SCT, vars = c("umap3d_1", "umap3d_2", "umap3d_3", "seurat_clusters", "Phase", "orig.ident"))

# Make a column of row name identities (these will be your cell/barcode names)
plot.data$label <- paste(rownames(plot.data))

# Plot your data
#When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

fig <- plot_ly(data = plot.data, 
        x = ~umap3d_1, y = ~umap3d_2, z = ~umap3d_3, 
        color = ~seurat_clusters, 
        colors = c("lightseagreen", "gray50", "darkgreen", "red4", "red", "turquoise4",
                   "black", "yellow4", "royalblue1", "lightcyan3", "peachpuff3",
                   "khaki3", "gray20", "orange2", "royalblue4", "yellow3", "gray80",
                   "darkorchid1", "lawngreen", "plum2", "darkmagenta"),
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 3, width=2), # controls size of points
        text=~orig.ident,
        hoverinfo="text") 
fig

fig <- plot_ly(data = plot.data, 
        x = ~umap3d_1, y = ~umap3d_2, z = ~umap3d_3, 
        color = ~Phase,
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 3, width=2), # controls size of points
        text=~orig.ident,
        hoverinfo="text") 

fig

rm(plot.data)

```

## Export
```{r}
if(export){
saveRDS(scRNA_SCT, file = "data/Bakhoum_scRNA_SCT.rds")

}

scRNA_SCT <- readRDS(file = "data/Bakhoum_scRNA_SCT.rds")

```

# Using SCTransform and regressing cell cycle

```{r}
scRNA_SCT_cellreg <- SCTransform(scRNA_c, verbose = FALSE)

# Add CIN status meta data
scRNA_SCT_cellreg@meta.data <- scRNA_SCT_cellreg@meta.data %>% mutate(CIN_status = ifelse(orig.ident %in% c("dnMCAK"),"CIN-high","CIN-low"))

# Score cell cycle
scRNA_SCT_cellreg <- CellCycleScoring(scRNA_SCT_cellreg, s.features = s.genes, g2m.features = g2m.genes)

# Regress cell cycle scores
vars_to_regress <- c("S.Score", "G2M.Score")

scRNA_SCT_cellreg <- SCTransform(scRNA_SCT_cellreg, vars.to.regress = vars_to_regress, verbose = FALSE)

```
## Perform PCA
```{r}
# Perform PCA
scRNA_SCT_cellreg <- RunPCA(scRNA_SCT_cellreg, npcs = 200)

# Plot PCA results
Idents(scRNA_SCT_cellreg) <- "orig.ident"
VizDimLoadings(scRNA_SCT_cellreg, dims = 1:2, reduction = "pca")
DimPlot(scRNA_SCT_cellreg, reduction = "pca")
ElbowPlot(scRNA_SCT_cellreg, ndims = 200)

# Check the total variance explained
# On Seurat 3:
pca <- scRNA_SCT_cellreg[["pca"]]
# Get the total variance of the scaled counts matrix:
mat <- Seurat::GetAssayData(scRNA_SCT_cellreg, assay = "SCT", slot = "scale.data")

total_variance <- sum(matrixStats::rowVars(mat))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance

varExplained

cumsum(varExplained) %>% as.data.frame() %>% rename("cumvar" = ".") %>% ggplot(aes(x = c(1:200), y = cumvar)) + geom_point() + labs(x = "PC #", y = "Cumulative Variance")

rm(mat)
rm(pca)

```

## Clustering cells
```{r}
# Clustering cells
scRNA_SCT_cellreg <- FindNeighbors(scRNA_SCT_cellreg, dims = 1:200)
scRNA_SCT_cellreg <- FindClusters(scRNA_SCT_cellreg, resolution = 0.5)

scRNA_SCT_cellreg <- StashIdent(scRNA_SCT_cellreg, save.name = "clusterID")

# Inspect cluster information
#head(Idents(scRNA_cn), 5)
Idents(scRNA_SCT_cellreg) <- "clusterID"

table(scRNA_SCT_cellreg$clusterID)
prop.table(table(scRNA_SCT_cellreg$clusterID))
prop.table(table(scRNA_SCT_cellreg$clusterID, scRNA_SCT_cellreg$orig.ident), margin = 2)
prop.table(table(scRNA_SCT_cellreg$orig.ident, scRNA_SCT_cellreg$clusterID), margin = 2)

prop.table(table(scRNA_SCT_cellreg$clusterID, scRNA_SCT_cellreg$CIN_status), margin = 2)
prop.table(table(scRNA_SCT_cellreg$CIN_status, scRNA_SCT_cellreg$clusterID), margin = 2)

table(scRNA_SCT$clusterID, scRNA_SCT_cellreg$CIN_status) %>% as.data.frame() %>% rename("clusterID" = Var1, "group" = Var2) %>% ggplot(aes(x = clusterID, y = group, fill = Freq)) + geom_tile() + scale_fill_distiller(palette = "PuBu") + geom_text(aes(label=Freq)) + labs(y = "", fill = "Number of cells")

```

```{r}

prop.table(table(scRNA_SCT_cellreg$CIN_status, scRNA_SCT_cellreg$clusterID), margin = 2)

cluster_assignment <- prop.table(table(scRNA_SCT_cellreg$CIN_status, scRNA_SCT_cellreg$clusterID), margin = 2) %>% as.data.frame() %>% rename("CIN_status" = Var1, "cluster" = Var2)

cluster_assignment$CIN_status <- gsub("-", "_", cluster_assignment$CIN_status)

cluster_assignment <- cluster_assignment %>% pivot_wider(values_from = Freq, names_from = CIN_status) %>% mutate(CIN_status = ifelse(CIN_high < 0.15, "CIN-low", "CIN-high"))

cluster_assignment
```

## Run UMAP and TSNE
```{r}
# Dimensionality reduction with UMAP on variable features instead of PCs
scRNA_SCT_cellreg <- RunUMAP(scRNA_SCT_cellreg, assay = "SCT", reduction.use = NULL, features = VariableFeatures(scRNA_SCT_cellreg))

# Store this UMAP as a custom reduction
scRNA_SCT_cellreg[["UMAP_features"]] <- CreateDimReducObject(embeddings = scRNA_SCT_cellreg@reductions$umap@cell.embeddings, key = "UMAP_features", assay = DefaultAssay(scRNA_SCT_cellreg))

# Run UMAP and project in 3D dimensions
scRNA_SCT_cellreg <- RunUMAP(scRNA_SCT_cellreg, dims = 1:200, n.components = 3L)

# Store this UMAP as a custom reduction
scRNA_SCT_cellreg[["umap3d"]] <- CreateDimReducObject(embeddings = scRNA_SCT_cellreg@reductions$umap@cell.embeddings, key = "umap3d", assay = DefaultAssay(scRNA_SCT_cellreg))

# PCs seem to be using the regressed data as intended

# Dimensionality reduction with UMAP on PCs
scRNA_SCT_cellreg <- RunUMAP(scRNA_SCT_cellreg, dims = 1:200)

```

## Visualization
```{r}
DimPlot(scRNA_SCT_cellreg, reduction = "umap", group.by = "CIN_status")
DimPlot(scRNA_SCT_cellreg, reduction = "umap", group.by = "orig.ident")
DimPlot(scRNA_SCT_cellreg, reduction = "umap", group.by = "Phase")
DimPlot(scRNA_SCT_cellreg, reduction = "umap", group.by = "clusterID")
```

## 3D UMAP
```{r}
# Visualize what headings are called so that you can extract them to form a dataframe
Embeddings(object = scRNA_SCT_cellreg, reduction = "umap3d") %>% head()

# Prepare a dataframe for cell plotting
plot.data <- FetchData(object = scRNA_SCT_cellreg, vars = c("umap3d_1", "umap3d_2", "umap3d_3", "seurat_clusters", "Phase", "orig.ident"))

# Make a column of row name identities (these will be your cell/barcode names)
plot.data$label <- paste(rownames(plot.data))

# Plot your data
#When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

fig <- plot_ly(data = plot.data, 
        x = ~umap3d_1, y = ~umap3d_2, z = ~umap3d_3, 
        color = ~seurat_clusters, 
        colors = c("lightseagreen", "gray50", "darkgreen", "red4", "red", "turquoise4",
                   "black", "yellow4", "royalblue1", "lightcyan3", "peachpuff3",
                   "khaki3", "gray20", "orange2", "royalblue4", "yellow3", "gray80",
                   "darkorchid1", "lawngreen", "plum2", "darkmagenta"),
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 3, width=2), # controls size of points
        text=~orig.ident,
        hoverinfo="text") 
fig

fig <- plot_ly(data = plot.data, 
        x = ~umap3d_1, y = ~umap3d_2, z = ~umap3d_3, 
        color = ~Phase,
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 3, width=2), # controls size of points
        text=~orig.ident,
        hoverinfo="text") 

fig

rm(plot.data)

```

## Cluster markers
```{r}
# Find cluster markers 
Idents(scRNA_SCT_cellreg) <- "clusterID"
SCT_cellreg.cluster.DE <- FindAllMarkers(scRNA_SCT_cellreg, min.pct = 0.05, logfc.threshold = 0)

#cluster.markers
clustertop10 <- SCT_cellreg.cluster.DE %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)

SCT_cellreg.cluster.DE %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)

```

## Plotting signatures
```{r}
Idents(scRNA_SCT_cellreg) <- "clusterID"

# Plotting EMT signature 
EMT_signature <- c("VIM", "ZEB2", "SNAI2", "ZEB1")

VlnPlot(scRNA_SCT_cellreg, features = EMT_signature)
FeaturePlot(scRNA_SCT_cellreg, features = EMT_signature)

EMT_signature2 <- c("EZH", "JUN", "VIM", "STEAP1", "SOX4", "MMP14", "SHH", "TIMP1", "ZEB1")

EMT_signature2 <- EMT_signature2[EMT_signature2 %in% rownames(scRNA_SCT_cellreg@assays$RNA)]

Idents(scRNA_SCT_cellreg) <- "clusterID"
for(i in 1:length(EMT_signature2)){
p <- VlnPlot(scRNA_SCT_cellreg, features = EMT_signature2[i])
print(p)
}

```

```{r}
# Plotting Genes enriched in the "M" Population from Bakhoum et al
M_markers = c("ITGB5", "ITGB1", "ITGA5", "ITGA10", "IGFBP4", "FN1", "DSC2", "CXCL1","CTNNB1", "BMP4", "BCL2L1")

for(i in 1:length(M_markers)){
p <- VlnPlot(scRNA_SCT_cellreg, features = M_markers[i])
print(p)
}
```

```{r}
# Plot CIN signature from Bakhoum et al 2018 (Supp. table 5), comparing CIN high and CIN low
CIN_signature <- c('PELI2','BMP2','SHH','TNS4','RAB3B','ROBO1','ARHGAP28','CHN2','CST1','F13A1','CPVL','SEMA6D','NHSL2','GTF2IP7','DPYSL3','PCDH7','KHDRBS3','TRAC','TMEM156',
'CST4','CD24','FGF5','NTN4')

CIN_present <- CIN_signature %in% rownames(scRNA_SCT_cellreg@assays$RNA)

for(i in 1:length(CIN_present)){
p <- VlnPlot(scRNA_SCT_cellreg, features = CIN_signature[CIN_present][i])
print(p)
}

```

## FGSEA DE between clusters
```{r}
scRNA_SCT_cellreg.l <- SCT_cellreg.cluster.DE %>% select(gene, cluster, avg_log2FC) %>% split(f = SCT_cellreg.cluster.DE$cluster)

SCT.cellreg.cluster.DE.fgsea <- scRNA_SCT_cellreg.l %>% lapply(FUN = function(x){
  x <- x %>% select(-cluster) %>% deframe()
  x <- fgsea(pathways = msigdb_hallmarks_set, 
                  stats = x,
                  minSize = 15,
                  maxSize = 500)
})


# Plot results for the GSEA on each cluster 
lapply(seq_along(SCT.cellreg.cluster.DE.fgsea), FUN = function(i){
  SCT.cellreg.cluster.DE.fgsea[[i]] <- SCT.cellreg.cluster.DE.fgsea[[i]] %>% mutate(
    within_threshold = pval < 0.05, 
    pval = ifelse(pval < 0.0001, 0.000101, pval)
    ) %>% left_join(msigdb_hallmarks_names)

  SCT.cellreg.cluster.DE.fgsea[[i]] %>% ggplot(aes(x = log10(pval), y = NES)) +
  geom_point(aes(size = 0.5, alpha = 0.3, col = as.factor(sign(NES)))) + 
  geom_hline(yintercept = 0, col = "black") +
  geom_text_repel(
  aes(x = log10(pval), y = NES, label = name), data = SCT.cellreg.cluster.DE.fgsea[[i]] %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
  ) +
  labs(x = "log10(pval)", y = "Normalized Enrichment Score", col = "Enriched in Cluster", title = paste("Cluster: ", i - 1, sep = "")) + 
  scale_y_continuous(limits = c(-3,3), breaks = seq(-3,3,1)) + 
  scale_x_continuous(trans = "reverse", limits = c(0, -4), breaks = c(-4, -3, -2, -1, 0) , labels = c("<0.0001", "0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)
})


# Combine summaries from the GO enrichment tests
SCT.cellreg.cluster.DE.fgsea_summary <- SCT.cellreg.cluster.DE.fgsea[[1]] %>% mutate(cluster = 0) %>% filter(pval == "nothing")

for(i in 1:length(SCT.cellreg.cluster.DE.fgsea)){
  print(i)
  SCT.cellreg.cluster.DE.fgsea_summary <- rbind(
    SCT.cellreg.cluster.DE.fgsea_summary, 
    SCT.cellreg.cluster.DE.fgsea[[i]] %>% mutate(cluster = i-1)
    )
}

if(export){
SCT.cellreg.cluster.DE.fgsea_summary %>% select(-leadingEdge) %>% write.csv2("data/scRNA_SCT_cellreg_cluster_fgsea.csv", row.names = FALSE)
}

SCT.cellreg.cluster.DE.fgsea_summary <- read.csv2("data/scRNA_SCT_cellreg_cluster_fgsea.csv")
SCT.cellreg.cluster.DE.fgsea <- SCT.cellreg.cluster.DE.fgsea_summary %>% split(f = SCT.cellreg.cluster.DE.fgsea_summary$cluster)


```
## Heatmap Cluster NES
```{r}
colfunc <- colorRampPalette(c("blue", "white", "red"))

SCT.cellreg.cluster.DE.fgsea_summary %>% left_join(msigdb_hallmarks_names) %>% select(name, NES, cluster) %>% pivot_wider(values_from = NES, names_from = name) %>% column_to_rownames("cluster") %>% mutate_all(~replace(., is.na(.), 0)) %>% as.matrix() %>% pheatmap(col=colfunc(10))

SCT.cellreg.cluster.DE.fgsea_summary %>% left_join(msigdb_hallmarks_names) %>% select(name, NES, cluster) %>% pivot_wider(values_from = NES, names_from = name)  %>% 
  column_to_rownames(var = "cluster") %>% mutate_all(~replace(., is.na(.), 0)) %>% as.matrix() %>%
  heatmap.2(col=colfunc(10), dendrogram = "both", trace = "none", srtCol=75)

```
## Export
```{r}
if(export){
saveRDS(scRNA_SCT_cellreg, file = "data/Bakhoum_scRNA_SCT_cellreg.rds")
  
SCT_cellreg.cluster.DE %>% write.csv2("data/Bakhoum_scRNA_SCT_cellreg_cluster_markers.csv", row.names = FALSE)

}

scRNA_SCT_cellreg <- readRDS(file = "data/Bakhoum_scRNA_SCT_cellreg.rds")
SCT_cellreg.cluster.DE <- read.csv2("data/Bakhoum_scRNA_SCT_cellreg_cluster_markers.csv")
```

#----------------------------------------------------------------------

# Inspect Batch effects
Look for batch effects by scaling and normalizing each dataset individually first, then merging
```{r}
# To compare batch effects, normalize and scale each dataset individually, then merge

# Kif2b
median_library_size <- kif2b_f@assays$RNA %>% colSums() %>% median()
# Normalize dataset
kif2b_fn <- NormalizeData(kif2b_f, normalization.method = "LogNormalize", scale.factor = median_library_size)
# find highly variable features with a variance stabilizing transform
kif2b_fn <- FindVariableFeatures(kif2b_fn, selection.method = "vst", nfeatures = 2000)


# Scale dataset
kif2b_fn <- ScaleData(kif2b_fn, features = rownames(kif2b_fn))

# MCAK
median_library_size <- MCAK_f@assays$RNA %>% colSums() %>% median()
# Normalize dataset
MCAK_fn <- NormalizeData(MCAK_f, normalization.method = "LogNormalize", scale.factor = median_library_size)
# find highly variable features with a variance stabilizing transform
MCAK_fn <- FindVariableFeatures(MCAK_fn, selection.method = "vst", nfeatures = 2000)
# Scale dataset
MCAK_fn <- ScaleData(MCAK_fn, features = rownames(MCAK_fn))


# dnMCAK
median_library_size <- dnMCAK_f@assays$RNA %>% colSums() %>% median()
# Normalize dataset
dnMCAK_fn <- NormalizeData(dnMCAK_f, normalization.method = "LogNormalize", scale.factor = median_library_size)
# find highly variable features with a variance stabilizing transform
dnMCAK_fn <- FindVariableFeatures(dnMCAK_fn, selection.method = "vst", nfeatures = 2000)
# Scale dataset
dnMCAK_fn <- ScaleData(dnMCAK_fn, features = rownames(dnMCAK_fn))


# Merge datasets, keeping the normalization and scaling on the data
scRNA_norm_c <- merge(kif2b_fn, y = c(MCAK_fn, dnMCAK_fn), add.cell.ids = c("kif2b", "MCAK", "dnMCAK"), project = "BakhoumCIN2018", merge.data = TRUE)

# Normalize, find variable features and scale the merged dataset
scRNA_norm_cn <- NormalizeData(scRNA_norm_c, normalization.method = "LogNormalize")
scRNA_norm_cn <- FindVariableFeatures(scRNA_norm_cn, selection.method = "vst", nfeatures = 2000)
scRNA_norm_cn <- ScaleData(scRNA_norm_cn, features = rownames(scRNA_norm_cn))

rm(scRNA_norm_c)
rm(kif2b_f)
rm(MCAK_f)
rm(dnMCAK_f)

```

```{r}
# Perform PCA
scRNA_norm_cn <- RunPCA(scRNA_norm_cn, features = VariableFeatures(object = scRNA_norm_cn), npcs = 200)

# Plot PCA results
DimPlot(scRNA_norm_cn, reduction = "pca", group.by = "orig.ident")
ElbowPlot(scRNA_norm_cn, ndims = 200)

# Cluster the cells using the first 200 principal components.

scRNA_norm_cn <- FindNeighbors(scRNA_norm_cn, dims = 1:200)
scRNA_norm_cn <- FindClusters(scRNA_norm_cn, resolution = 0.5)

scRNA_norm_cn <- StashIdent(scRNA_norm_cn, save.name = "clusterID")

scRNA_norm_cn <- RunUMAP(scRNA_norm_cn, dims = 1:200)
scRNA_norm_cn <- RunTSNE(scRNA_norm_cn, dims.use = 1:200, reduction.use = "pca", perplexity = 30)

```

```{r}
# Inspect dataset, looking for batch effects
VlnPlot(scRNA_norm_cn, features = c("nFeature_RNA", "nCount_RNA"), group.by = "orig.ident", ncol=2)

# Plot PCA results
DimPlot(scRNA_norm_cn, reduction = "pca", group.by = "orig.ident")

DimPlot(scRNA_norm_cn, reduction = "umap", group.by = "clusterID")
DimPlot(scRNA_norm_cn, reduction = "umap", group.by = "orig.ident")
DimPlot(scRNA_norm_cn, reduction = "tsne", group.by = "clusterID")
DimPlot(scRNA_norm_cn, reduction = "tsne", group.by = "orig.ident")

```

```{r}
# Export Seurat object with processed individual datasets prior to merging, re-normalizing and scaling again
if(export){
saveRDS(scRNA_norm_cn, file = "data/Bakhoum_scRNA_norm_cn.rds")
  }
#scRNA_cn <- readRDS(file = "data/Bakhoum_scRNA_norm_cn.rds")

rm(scRNA_norm_cn)
```

# Seurat integration
Try to correct for batch effects with Seurat integration 
```{r}
# Explore batch correction with Seurat integration workflow
ob.list <- list(kif2b_fn, MCAK_fn, dnMCAK_fn)

# ob.list <- lapply(list(kif2b_f, MCAK_f, dnMCAK_f), FUN = function(x){
#   x <- NormalizeData(x)
#   x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
# }
# )

features <- SelectIntegrationFeatures(object.list = ob.list)

CINanchors <- FindIntegrationAnchors(object.list = ob.list, anchor.features = features)

IntegratedCIN <- IntegrateData(anchorset = CINanchors)

# Assign and inspect cell cycle scores
IntegratedCIN <- CellCycleScoring(IntegratedCIN, s.features = s.genes, g2m.features = g2m.genes)

```

```{r}
# specify that we will perform downstream analysis on the corrected data note that the original
# unmodified data still resides in the 'RNA' assay
DefaultAssay(IntegratedCIN) <- "integrated"

# Run the standard workflow for visualization and clustering
IntegratedCIN <- ScaleData(IntegratedCIN, verbose = FALSE)
IntegratedCIN <- RunPCA(IntegratedCIN, npcs = 200, verbose = FALSE)
IntegratedCIN <- RunUMAP(IntegratedCIN, reduction = "pca", dims = 1:200)
IntegratedCIN <- RunTSNE(IntegratedCIN, reduction = "pca", dims = 1:200)
IntegratedCIN <- FindNeighbors(IntegratedCIN, reduction = "pca", dims = 1:200)
IntegratedCIN <- FindClusters(IntegratedCIN, resolution = 0.5)

DimPlot(IntegratedCIN, reduction = "umap", group.by = "orig.ident")
DimPlot(IntegratedCIN, reduction = "umap", group.by = "Phase")
DimPlot(IntegratedCIN, reduction = "umap", split.by = "orig.ident")

DimPlot(IntegratedCIN, reduction = "umap", label = TRUE, repel = TRUE)

DimPlot(IntegratedCIN, reduction = "tsne", group.by = "orig.ident")
DimPlot(IntegratedCIN, reduction = "tsne", group.by = "Phase")
DimPlot(IntegratedCIN, reduction = "tsne", label = TRUE, repel = TRUE)

```

```{r}
if(export){
saveRDS(IntegratedCIN, file = "data/Bakhoum_integrated_scRNA.rds")
}
```

