---
title: "Transcriptomics"
author: "Pedro Batista Tan. Adapted from the tutorial of Hugo Pineda, Joeri Jongbloets"
date: "`r strftime(Sys.Date(), '%B %d %Y')`"
output:
  html_document:
    toc: yes
    number_sections: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, warning=FALSE, message = FALSE, dpi = 300
  # fig.width = 10, fig.height = 6
)

# install.packages("BiocManager") #(only if you do not have BiocManager)
# BiocManager::install("DESeq2")
# BiocManager::install("apeglm")
library(DESeq2)
# install.packages("broom")
library(broom)
# install.packages("patchwork")
library(patchwork)
# install.packages("ggfortify")
library(ggfortify)
# install.packages("colorspace")
library(colorspace)
# install.packages("GGally")
library(GGally)
# install.packages("ggrepel")
library(ggrepel)
# install.packages("AnnotationDbi")
library("AnnotationDbi")
# install.packages("tidyverse")
library(tidyverse)
# install.packages("gplots")
library(gplots)
# install.packages("pheatmap")
library(pheatmap)
# install.packages("RColorBrewer")
library(RColorBrewer)
#BiocManager::install("org.Hs.eg.db")
library("org.Hs.eg.db")

#install.packages("vsn")
#library("vsn")
#meanSdPlot(assay(vsd))

select = dplyr::select
```

```{r load_data, include=FALSE}
# Load ensembl gene database
ensembl_db <- read.csv("EnsDb.Hsapiens.v86.csv")

# Load transcriptomics count data
# Each row is a gene, each column a sample
df.counts.raw <- read.csv("data/GSE98183_Counts.geneSymbols.75bpPE.csv") 
# df.counts.raw2 <- read.csv("data/GSE98183_Counts.geneSymbols.101bpSE.csv") 

# load sample design
design <- read.csv2("data/samples.csv")
colnames(design) <- c("Sample", "Name", "Group")

# Sample names
colnames(df.counts.raw)
colnames(df.counts.raw) <- c("gene", "MK", "MKH", "Kb", "Ka", "cont")

# generate output dir path named data
source.output.dir <- file.path("data")

# if source output dir does not exist, create it
if (!dir.exists(source.output.dir)) {
    dir.create(source.output.dir)
} else{
  print("Data folder already exists")
}
```

```{r}
# Summary of dataframe with columns as factors
df.counts.raw %>% lapply(as.character) %>% lapply(as.factor) %>% as.data.frame() %>% summary()
```

```{r}
# Compute and plot total counts per sample
df.counts.raw %>% column_to_rownames("gene") %>% colSums() %>% data.frame() %>% rename("Value" = ".") %>% rownames_to_column("Sample") %>% 
  ggplot(aes(x = Sample, y = Value, fill = Sample)) + geom_col() + labs(x = "Sample_ID", y = "Raw Counts", title = "Raw total counts") + theme(plot.title = element_text(hjust= 0.5), legend.position = "none") + scale_y_continuous(labels = scales::comma) + scale_fill_viridis_d()

```

## Ribosomal RNA 

Out of all the RNA present in a prokaryotic cell, roughly 85% is ribosomal (r)RNAs. Thus when sequencing RNA 85% of the reads will be on non-coding rRNA, while we are interested in mRNA. To improve sensitivity and dynamic range on the mRNA levels we remove the rRNA, called ribosomal RNA depletion. We should check if this procedure was effective.
  
```{r}
# Some of the gene names in the count data correspond to the gene_name, some to the gene_id

# Create a "gene" column in the ensembl_db that corresponds to either the id or the name,
# depending on how it was annotated in the count data


gene_ensembl_db <- df.counts.raw %>% select(gene) %>% inner_join(ensembl_db %>% mutate(gene = gene_name)) %>% rbind(
  df.counts.raw %>% select(gene) %>% inner_join(ensembl_db %>% mutate("gene" = gene_id))
  )

# Convert dataframe to long format
df.counts.long <- df.counts.raw %>% pivot_longer(cols = c(-gene), values_to = "Count",  names_to = "Sample")

# The top most expressed genes are rRNA, filter out?
df.counts.long %>% group_by(gene) %>% summarize(mean = mean(Count)) %>% ungroup() %>% 
  left_join(gene_ensembl_db, by = "gene") %>% arrange(-mean)

# Check types of genes
gene_ensembl_db$gene_biotype %>% as.factor() %>% levels()

# Plot the proportion of rRNA in each sample
df.counts.long %>% group_by(Sample) %>% left_join(gene_ensembl_db, by = "gene") %>%
  mutate(raw_total = sum(Count)) %>%
  filter(gene_biotype %in% c("rRNA", "Mt_rRNA")) %>% group_by(Sample, raw_total) %>% summarize(rRNA_sum = sum(Count)) %>%
  mutate(fraction_rRNA = rRNA_sum/raw_total) %>%
  ggplot(aes(x = Sample, y = fraction_rRNA, fill = Sample)) + geom_col() + labs(x = "Sequence ID", y = "Percentage of rRNA", title = "percentage of rRNA and Mt_rRNA") + theme(plot.title = element_text(hjust= 0.5), legend.position = "none") + scale_y_continuous(labels = scales::percent) + scale_fill_viridis_d()

```

## Filtering out low-count genes and rRNA

```{r}
# Check how many genes have a sample with at least X counts
df.counts.long %>%
  group_by(gene) %>% filter(any(Count > 23)) %>% 
  mutate(counts_log2 = log2(Count+1)) %>% ungroup() %>% select(gene) %>% n_distinct()

# filter out genes for which all the samples have 0 counts.
# Also create a column for log2 of pseudocounts
df.counts.f <- df.counts.long %>%
  group_by(gene) %>% filter(any(Count > 0)) %>% 
  mutate(counts_log2 = log2(Count+1)) %>% ungroup()

# Compare the dimensions of the datasets
dim(df.counts.long)
dim(df.counts.f)

df.counts.raw$gene %>% n_distinct()
df.counts.f$gene %>% n_distinct()

```

## Visualizing counts' distribution:

Visualize the distribution of the counts in log space.

Are the samples similar or different? Do you see outliers? Can you conclude that the values are consistent, or is a normalization step required?
```{r}
# make a boxplot using the counts_log2 column
df.counts.f %>% ggplot(aes(x = Sample, y = counts_log2, col = Sample)) + geom_boxplot() + labs(x = "Sample", y = "log2 Counts", title = "Distribution of Log2 Counts") + theme(legend.position = "none", plot.title = element_text(hjust= 0.5)) + scale_fill_brewer(palette = "Dark2")

# make a density using the counts_log2 column
df.counts.f %>% ggplot(aes(counts_log2, col = Sample)) + geom_density()
```

## Sample comparison 

An important aspect of quality control is comparing the samples. A direct way of comparing the samples is to plot the gene expression levels of one sample against the gene expression levels of another sample. 

```{r}
# use pivot_wider to change to long format. Take the values from the `counts_log2` column
df.counts.f.wide <- df.counts.f %>% select(-c(Count)) %>% pivot_wider(names_from = Sample, values_from = counts_log2)
```

```{r}
# make a scatterplot of MK vs MKH log2 counts
df.counts.f.wide %>% ggplot(aes(x = MK, y = MKH)) + geom_point(alpha = 0.75, size = 0.5) + geom_abline(intercept = 0, slope =1, col = "red") + labs(x = "MK Log2 Counts", y = "MKH Log2 Counts", title = "Log2 Counts") + theme(plot.title = element_text(hjust= 0.5))
```

```{r}
# Compare the expression of genes between all pairs of samples
df.counts.f.wide %>% select(-c(gene)) %>% ggpairs(
  lower = list(continuous = wrap("points", alpha = 0.3, size = 0.5))
)
```
## MA plots

Although this plot is very informative, it is often more informative and common to compare the gene expression values between samples (or conditions) using an MA plot. In an MA plot you plot the difference in gene expression for each gene on the y-axis. The total expression level is plotted on the x-axis. It was originally developed for microarray data (http://en.wikipedia.org/wiki/MA_plot), but is also widely used for RNA-seq data.

The advantage is that differences from zero in the y-axis directly indicate a difference in log2 fold change. Each dot indicates a gene, and dots on the left side in the graph have a low expression level, and genes on the right side in the graph have a high expression level.

To analyze all 6 samples, it is handy to compare them all with a common reference. This common reference is the based median expression level of each gene across all samples. Use the `df.counts.f` data.frame to first calculate the log2 of the median counts per gene and then calculate M and A per sample.

```{r}
# calculate the log2 of the median counts per gene 
  # calculate M and A per sample
df.MA <- df.counts.f %>% group_by(gene) %>% mutate(common_ref = log2(median(Count))) %>% ungroup()

# M: difference between samples
# A: total counts for both samples
# Make a scatterplot of M vs A. Straight line with intercept = 0
df.MA %>% ggplot(aes(x = (counts_log2 + common_ref), y = (counts_log2 - common_ref))) + geom_point(size = 0.75) + facet_wrap(~Sample) + geom_hline(yintercept = 0, col = "red", size = 1) + labs(x = "A (versus reference)", y = "M (versus reference)", title = "Log2 Counts MA Plot") + theme(plot.title = element_text(hjust= 0.5))

rm(df.MA)
rm(df.counts.long)
rm(df.counts.f.wide)
```

# Differential Expression

We are analyzing our data using the `DESeq2` package. The goal of is to find differentially expressed genes.

## Preparing the data for DESeq2

DESeq2 needs as inputs, at least, 3 objects:

- countData: a matrix containing genes in rows and samples in columns. Gene names should be set as the row names of the matrix.
- colData: a data.frame with two columns, one containing the sample names and the other one containing the experimental conditions (in our case, control and treatment).
- design: a formula indicating the name of the column in the colData object that contains the experimental conditions.

```{r}
# join design data
# Convert CIN-medium label to CIN-High, as done in the paper
design_c <- design %>% mutate(Group = ifelse(Group == "CIN-medium", "CIN-high", Group))

df.counts.f <- df.counts.f %>% left_join(design_c,  by = "Sample")
```

Create the object for countData. Transform the df.diff to wide format, set the genes as row names and convert to matrix.

```{r}
# select only the necessary columns
# tranform to wide format
# set the row names
# transform to to matrix.
df.diff.wide <- df.counts.f %>% 
  arrange(Group) %>% 
  select(gene, Count, Sample) %>% 
  pivot_wider(
    names_from = Sample, 
    values_from =  Count
    ) %>% column_to_rownames("gene") %>%
  as.matrix()

head(df.diff.wide)

```

```{r}
  # get the unique combinations of sample and group, arrange by group
  # convert sequence_id and purpose columns to factors.
  # Rows must be in the same order as the columns of the count matrix
df.diff.design <- df.counts.f %>% 
  distinct(Sample, Group) %>%
  arrange(Group)%>%
  mutate(
    Sample = as.factor(Sample),
    Group = as.factor(Group)
  )
head(df.diff.design)

```

Create the DESeq2 object and estimate size factors to apply counts normalization

```{r}
# create the deseq dataset
deseq.dataset <- DESeqDataSetFromMatrix(
  countData=as.matrix(df.diff.wide),
  colData=df.diff.design,
  design=~Group
) %>%
  estimateSizeFactors()

# Change factor levels to compare CIN-High x CIN-low (default is alphabetical)
deseq.dataset$Group <- factor(deseq.dataset$Group, levels = c("CIN-low","CIN-high"))

```

## Counts normalization

The previous function call creates a DESeq2 object which, among many other things, contains the normalized counts and the estimated size factors.

You can access the normalized counts from the DESeq object by calling the `counts` function with `normalized = TRUE`. 

```{r}
# Get the size factors by using the `sizeFactors()` function and the created DESeq object
deseq.dataset %>% sizeFactors() %>% 
  enframe(name = "Sample", value = "size_factor") %>% 
  arrange(Sample)

deseq.dataset.norm <- deseq.dataset %>%
  counts(normalized=TRUE) %>% as.data.frame()
deseq.dataset.norm %>% head()

deseq.dataset.norm.long <- deseq.dataset.norm %>% rownames_to_column("gene") %>% pivot_longer(cols = c(-gene), values_to = "counts", names_to = "Sample")
deseq.dataset.norm.long %>% head()
```

```{r}
# Plot total number of normalized counts, that used size factors from DESEq
deseq.dataset.norm.long %>% 
  group_by(Sample) %>%
  summarise(
    total_counts_norm = sum(counts)
  ) %>%
  ggplot(aes(x = Sample, y = total_counts_norm, fill= Sample)) +
  geom_col() +
  scale_fill_viridis_d() +
  labs(x= "", y = "Total Counts per Sample", title = "Total normalized counts") + theme(plot.title = element_text(hjust= 0.5), legend.position = "hide") + scale_y_continuous(labels = scales::comma, breaks = seq(from = 0, to = 150000000, by = 10^7))
```

Make a boxplot to visualize the distribution of normalized counts, for every sample:

```{r }
# make boxplots for sample using the log2 transformed normalized (pseudo)counts
deseq.dataset.norm.long %>% 
  ggplot(aes(x = Sample, y = log2(counts+1), color = Sample)) + 
  geom_boxplot() +
labs(x= "Sample ID", y = "Log2 Counts", title = "Log2 count distribution") + theme(plot.title = element_text(hjust= 0.5), legend.position = "hide")

# make a density using the log2 transformed normalized counts
deseq.dataset.norm.long %>% ggplot(aes(log2(counts+1), col = Sample)) + geom_density()
```

Are the samples similar or different? Do you see outliers? Can you conclude that the normalization worked?

## Dispersion estimation

In RNA-seq count data there is a dependency between the variance and the mean that is addressed in the statistical procedures that are used for differential gene expression analysis. This plot visualizes the (overdispersed) mean-variance dependency in your normalized data:

Computing mean and variance:

```{r}
# create DESeq object
dds <- DESeq(deseq.dataset)
```

```{r}
resultsNames(dds)
res <- results(dds)

summary(res)
```


```{r}
# Plot variance over mean of normalized counts to check overdispersion

norm.counts <- counts(deseq.dataset, normalized=TRUE)

df.mean.var <- tibble(
  mean_counts = rowMeans(norm.counts),
  var =  apply(norm.counts, 1, var)
)

df.mean.var %>% 
  ggplot(aes(x = mean_counts, y = var)) +
    geom_point(alpha = 0.2) +
  labs(
    title = "Mean-variance relationship",
    x = "Mean log2(normalized counts) per gene",
    y = "Variance of log2(normalized counts)"
  ) +
  geom_abline(intercept = 0, slope = 1, colour = "brown") +
  scale_x_log10() +
  scale_y_log10()

rm(df.mean.var)
```
DESeq2 resolves this issue using regression and shrinkage:

```{r}
plotDispEsts(dds, log = "xy")
```

## Differential expression

In order to extract the results of the DESeq analysis, we need to call the `results()` function on the previously created DESeq object. The following code extracts into a data.frame the log fold change, the p-values and adjusted p-values for differential expression. 

```{r}
#?lfcShrink

resLFC <- lfcShrink(dds, coef = "Group_CIN.high_vs_CIN.low", type = "apeglm")

df.deseq.results <- resLFC %>%
  as.data.frame() %>%
  rownames_to_column("gene")

df.deseq.results %>% 
  head()

# df.deseq.results2 <- dds %>%
#   lfcShrink(contrast=c("Group","CIN-high","CIN-low"), type = "normal") %>%
#   as.data.frame() %>%
#   rownames_to_column("gene")
```

The results can be plotted in an MA plot:

```{r}
res %>% 
  plotMA(ylim=c(-5,5))

# MA plot on shrunken Log2 Fold Changes, also removes the ones with low counts
resLFC  %>% 
  plotMA(ylim=c(-5,5))
```
â€¦and you can plot the expression values of for instance the 10 most differentially expressed genes:

```{r}
df.deseq.results %>% 
  select(gene, padj) %>% 
  arrange(padj) %>%
  slice(1:10) %>%
  left_join(
    deseq.dataset.norm.long, by = "gene"
  ) %>%
  left_join(
    design_c, by = "Sample"
  ) %>%
  mutate(
    gene = reorder(gene, padj)
  ) %>%
  ggplot(aes(x=Group, y=log2(counts), colour=padj)) +
  facet_wrap(~gene, ncol = 5) +
  geom_point() +
  scale_color_viridis_c(limits = c(0, 1)) +
  labs(
    x = "", y= bquote("log"[2]~"Normalized Counts"), colour = "Adjusted P. Value"
  ) +
  theme(legend.position = 'bottom')
```

```{r}
# Check how many genes have an adj p-value < 0.01
df.deseq.results %>% filter(padj < 0.01) %>% select(gene) %>% n_distinct()
```

Draw an histogram of the p-values and the adjusted p-values

```{r}
# histogram of pvalues
df.deseq.results %>% 
  ggplot(aes(pvalue)) + geom_histogram() +   labs(
    title = "DESeq2 p-value distribution", 
    x = "DESeq2 P-value", 
    y = "Number of genes"
  ) +  # you can add two ggplot objects with `+` with the patchwork package
  df.deseq.results %>% 
  ggplot(aes(padj)) + geom_histogram() +   labs(
    title = "DESeq2 Adjusted p-value distribution", 
    x = "DESeq2 adjusted P-value", 
    y = "Number of genes"
  )
 # histogram of adj pvalues
```

Create a volcano plot.

```{r}
alpha = 0.001
log2FCthresh = 2
df.deseq.results <- df.deseq.results %>% mutate(
  within_threshold = (padj < alpha & abs(log2FoldChange) > log2FCthresh)
)

#df.volcano <- df.deseq.results %>% mutate(threshold = (abs(log2FoldChange) > 2 & padj < alpha))

df.deseq.results %>% ggplot(
  aes(x=log2FoldChange , y= -log10(padj + 1e-200), col = within_threshold)) +     geom_point(alpha = 0.5) +
geom_vline(xintercept = 0, col = "black") + 
geom_vline(xintercept = c(-log2FCthresh, log2FCthresh), col = "red") +   geom_hline(yintercept = -log10(alpha), colour = "red") + 
geom_text_repel(
  aes(x = log2FoldChange, y = -log10(padj + 1e-200), label = gene), data = df.deseq.results %>% filter(within_threshold), colour = "grey20"
  ) +
  theme(legend.position = "none", plot.title = element_text(hjust= 0.5)) +
  labs(
    title = "Volcano plot", 
    x = "Effect size: log2(fold-change)", 
    y = "-log10(adjusted p-value)"
  ) + ylim(0, 50) + 
  scale_x_continuous(breaks = seq(-6,9, by = 1))

# png(filename="data/volcano_plot.png", width=600, height=600)
# ggsave(file="data/volcano_plot.png", width=6, height=4, dpi=300)

```

```{r}
  # filter
df.deseq.results %>%
  filter(within_threshold == TRUE) %>% nrow()

df.deseq.results %>%
  filter(within_threshold == TRUE) %>%
  arrange(-log2FoldChange, padj) %>% head()
```

## Export
```{r}
df.deseq.results_map <- df.deseq.results %>% left_join(gene_ensembl_db %>% select(gene, gene_name, symbol) %>% unique())

# Add a column for negative log10 of pvalues
df.deseq.results_map <- df.deseq.results_map %>% mutate(neglog10padj = ifelse(padj != 0, -log10(padj), NA))

# Export data
df.deseq.results_map %>% write_csv2("data/bulk_transcriptomics_deseq.csv")

# DE genes using symmetrical threshold
df.deseq.results_map %>% filter(within_threshold == TRUE) %>% write_csv2(paste0("data/CIN-diff_deseq_DE_", alpha, "_FC", log2FCthresh, ".csv"))

# Genes up-regulated in CIN-high
alpha_up = 0.001
log2FCthresh_up = 1.75
n_genes_up <- df.deseq.results_map %>% filter(padj < alpha_up & log2FoldChange > log2FCthresh_up) %>% nrow()

df.deseq.results_map %>% filter(padj < alpha_up & log2FoldChange > log2FCthresh_up) %>% select(gene, gene_name, symbol) %>% write_csv2(paste0("data/CIN-high-up_", alpha_up, "_FC_", log2FCthresh_up, "_n", n_genes_up, ".csv"), quote = FALSE)

# Genes down-regulated in CIN-high
alpha_down = 0.05
log2FCthresh_down = -1
n_genes_down <- df.deseq.results_map %>% filter(padj < alpha_down & log2FoldChange < log2FCthresh_down) %>% nrow()

df.deseq.results_map %>% filter(padj < alpha_down & log2FoldChange < log2FCthresh_down) %>% select(gene, gene_name, symbol) %>% write_csv2(paste0("data/CIN-high-down_", alpha_down, "_FC_", log2FCthresh_down, "_n", n_genes_down, ".csv"), quote = FALSE)

```

```{r}
# Export normalized counts in the specific .txt format for GSEA analysis
# Description column is required, wasn't able to import in GSEA with "na" value
# Adding pseudocounts (0.1) to prevent 0 values in GSEA
norm.pseudocounts <- norm.counts + 0.1

# Use ensembl gene names for GSEA
norm.pseudocounts.df <- norm.pseudocounts %>% as.data.frame() %>% rownames_to_column("gene") %>% left_join(
  gene_ensembl_db %>% select(gene, gene_name, symbol) %>% unique()
  )

# If the gene symbol is not available, use the gene name instead (as in the counts df)
norm.pseudocounts.df <- norm.pseudocounts.df %>% mutate(gene_symbol = ifelse(is.na(symbol), gene, symbol)) 

norm.pseudocounts.df <- norm.pseudocounts.df %>% select(-c(gene, gene_name, symbol)) %>% 
  relocate(gene_symbol, 1) %>% dplyr::rename("NAME" = gene_symbol)


# Take the sum of all counts for genes with the same name (symbol)
norm.pseudocounts.df <- norm.pseudocounts.df %>% group_by(NAME) %>% summarize_all(.funs = sum) %>% ungroup() %>% mutate("DESCRIPTION" = 1) %>% relocate(DESCRIPTION, .after = NAME)

# Export normalized (pseudo)counts
norm.pseudocounts.df %>% write.table(file ="data/GSEA_CIN_high_low_pseudo.txt", sep = "\t", row.names = FALSE, quote = FALSE)


# Export ranked list for pre-ranked GSEA using shrunk log2fold changes 
# As the preranked GSEA can be run with gene symbols, use those instead of the IDs
df.deseq.results_map %>% arrange(-log2FoldChange) %>% mutate(gene_symbol = ifelse(is.na(symbol), gene, symbol)) %>% select(gene_symbol, log2FoldChange) %>% dplyr::rename("NAME" = gene_symbol) %>% write.table(file ="data/GSEA_preranked_CIN_high_low.rnk", sep = "\t", row.names = FALSE, quote = FALSE)


```


# GSEA
```{r}
# GSEA results
GSEA_pos <- read.table("data/CIN_high_low_preranked_log2FC.GseaPreranked/gsea_report_for_na_pos_1618265603872.tsv", header = TRUE, sep = "\t")

GSEA_neg <- read.table("data/CIN_high_low_preranked_log2FC.GseaPreranked/gsea_report_for_na_neg_1618265603872.tsv", header = TRUE, sep = "\t")

GSEA_res <- rbind(GSEA_pos, GSEA_neg) %>% mutate(within_threshold = FDR.q.val < 0.3) %>% mutate("Enriched_in" = ifelse(NES > 0, "CIN-high", "CIN-low"))

GSEA_res %>% select(-c(X, within_threshold)) %>% arrange(-NES) %>%  write_csv2("data/GSEA_CIN_DE_hallmarks.csv")

# Hallmark names
msigdb_hallmarks_names <- read.csv2("data/names_hallmarks.csv")

GSEA_res <- GSEA_res %>% left_join(msigdb_hallmarks_names %>% rename(NAME = pathway))
		
GSEA_res %>% 
  ggplot(aes(x = log10(FDR.q.val), y = NES)) +
  geom_point(aes(size = 0.5, alpha = 0.3, col = Enriched_in)) + 
  geom_hline(yintercept = 0, col = "black") +
  geom_text_repel(
  aes(x = log10(FDR.q.val), y = NES, label = name), data = GSEA_res %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
  ) +
  labs(x = "log10(FDRq)", y = "Normalized Enrichment Score", col = "Enriched in") + 
  scale_y_continuous(limits = c(-2,2), breaks = seq(-2,2,1)) + 
  scale_x_continuous(trans = "reverse", limits = c(0, -3), breaks = c(-3, -2, -1, 0) , labels = c("<0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)

# png(filename="data/GSEA_results.png", width=600, height=600)
# ggsave(file="data/GSEA_results.png", width=6, height=4, dpi=300)

```
# Compare with Bulk GSEA NES
```{r}
Bulk_gsea <- read.csv2("data/Supp_table6.csv")

# GSEA x Bulk
GSEA_comp <- Bulk_gsea %>% select(NAME, NES, FDR.q.val) %>% rename(orig_NES = NES, orig_FDR.q.val = FDR.q.val) %>% left_join(
  GSEA_res %>% select(NAME, NES, FDR.q.val)) %>% left_join(
  msigdb_hallmarks_names %>% rename(NAME = pathway)
  ) %>% mutate(sign_agreement = sign(orig_NES) == sign(NES))

GSEA_comp %>% ggplot(aes(x = orig_NES, y = NES, col = FDR.q.val)) + 
  geom_point() + geom_abline(slope = 1) + 
  geom_text_repel(
    aes(x = orig_NES, y = NES, label = name), data = GSEA_comp %>% filter(!sign_agreement), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  ) + labs(x = "Orig GSEA NES", y = "GSEA NES")

```

```{r}
# GSEA results
GSEA_pos <- read.table("data/CIN_high_low_hallmarks_symbols.GseaPreranked/gsea_report_for_na_pos_1618914115478.tsv", header = TRUE, sep = "\t")

GSEA_neg <- read.table("data/CIN_high_low_hallmarks_symbols.GseaPreranked/gsea_report_for_na_neg_1618914115478.tsv", header = TRUE, sep = "\t")

GSEA_res <- rbind(GSEA_pos, GSEA_neg) %>% mutate(within_threshold = FDR.q.val < 0.3) %>% mutate("Enriched_in" = ifelse(NES > 0, "CIN-high", "CIN-low"))

GSEA_res %>% select(-c(X, within_threshold)) %>% arrange(-NES) %>%  write_csv2("data/GSEA_CIN_DE_hallmarks.csv")

GSEA_res <- GSEA_res %>% left_join(msigdb_hallmarks_names %>% rename(NAME = pathway))

GSEA_res %>% 
  ggplot(aes(x = log10(FDR.q.val), y = NES)) +
  geom_point(aes(size = 0.5, alpha = 0.3, col = Enriched_in)) + 
  geom_hline(yintercept = 0, col = "black") +
  geom_text_repel(
  aes(x = log10(FDR.q.val), y = NES, label = name), data = GSEA_res %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
  ) +
  labs(x = "log10(FDRq)", y = "Normalized Enrichment Score", col = "Enriched in") + 
  scale_y_continuous(limits = c(-2,2), breaks = seq(-2,2,1)) + 
  scale_x_continuous(trans = "reverse", limits = c(0, -3), breaks = c(-3, -2, -1, 0) , labels = c("<0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)

#png(filename="data/GSEA_symbol_results.png", width=600, height=600)
#ggsave(file="data/GSEA_symbol_results.png", width=6, height=4, dpi=300)


# GSEA x Bulk
GSEA_comp <- Bulk_gsea %>% select(NAME, NES, FDR.q.val) %>% rename(orig_NES = NES, orig_FDR.q.val = FDR.q.val) %>% left_join(
  GSEA_res %>% select(NAME, NES, FDR.q.val)) %>% left_join(
  msigdb_hallmarks_names %>% rename(NAME = pathway)
  ) %>% mutate(sign_agreement = sign(orig_NES) == sign(NES))

GSEA_comp %>% ggplot(aes(x = orig_NES, y = NES, col = FDR.q.val)) + 
  geom_point() + geom_abline(slope = 1) + 
  geom_text_repel(
    aes(x = orig_NES, y = NES, label = name), data = GSEA_comp %>% filter(!sign_agreement), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0, max.overlaps = 20
  ) + labs(x = "Orig GSEA NES", y = "GSEA NES")

# png(filename="data/GSEA_symbol_x_orig.png", width=600, height=600)
# ggsave(file="data/GSEA_symbol_x_orig.png", width=6, height=4, dpi=300)
```

# Enrichr
```{r}
# Enrichr results
enrichr_diff <- read.table("data/Enrichr results/alpha0.001_FC2_diff/MSigDB_Hallmark_2020_table_ENRICHR.txt", sep = "\t", header = TRUE)

enrichr_up <- read.table("data/Enrichr results/alpha0.001_FC1.75_CIN_up/MSigDB_Hallmark_2020_table.txt", sep = "\t", header = TRUE)

enrichr_down <- read.table("data/Enrichr results/alpha0.05_FC-1_CIN_down/MSigDB_Hallmark_2020_table.txt", sep = "\t", header = TRUE)
```


```{r}
# Apply a variance stabilizing transform
vsd <- vst(dds, blind=FALSE)
vsd %>% assay() %>% head()

```

```{r}
# Heatmap on VSD data using top 20 genes
select <- order(rowMeans(counts(dds,normalized=TRUE)),
                decreasing=TRUE)[1:30]
df <- as.data.frame(colData(dds)[,c("Sample","Group")])
pheatmap(assay(vsd)[select,], cluster_rows=FALSE, show_rownames=FALSE,
         cluster_cols=FALSE, annotation_col=df)

```

```{r}
# Heatmap of sample distances
sampleDists <- dist(t(assay(vsd)))

sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- vsd$Group
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

```

Perform PCA on VST data 
```{r}
plotPCA(vsd, intgroup=c("Group"), returnData = TRUE)
plotPCA(vsd, intgroup=c("Group"))

plotPCA(vsd, intgroup=c("Group")) +
geom_text_repel(
  aes(x = PC1, y = PC2, label = name), data = plotPCA(vsd, intgroup=c("Group"), returnData = TRUE))
# png(filename="data/vst_pca.png", width=450, height=600)
# ggsave(file="data/vst_pca.png", width=4.5, height=4, dpi=300)

```

