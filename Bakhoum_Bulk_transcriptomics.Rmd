---
title: "Transcriptomics"
author: "Pedro Batista Tan. Adapted from the tutorial of Hugo Pineda, Joeri Jongbloets"
date: "`r strftime(Sys.Date(), '%B %d %Y')`"
output: 
  html_document:
    toc: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, warning=FALSE, message = FALSE
  # dpi = 300, fig.width = 10, fig.height = 6
)

# install.packages("BiocManager") #(only if you do not have BiocManager)
# BiocManager::install("DESeq2")
# BiocManager::install("apeglm")
library(DESeq2)
# install.packages("broom")
library(broom)
# install.packages("patchwork")
library(patchwork)
# install.packages("ggfortify")
library(ggfortify)
# install.packages("colorspace")
library(colorspace)
# install.packages("GGally")
library(GGally)
# install.packages("ggrepel")
library(ggrepel)
# install.packages("AnnotationDbi")
library("AnnotationDbi")
# install.packages("tidyverse")
library(tidyverse)
# install.packages("gplots")
library(gplots)
# install.packages("pheatmap")
library(pheatmap)
# install.packages("RColorBrewer")
library(RColorBrewer)
#BiocManager::install("org.Hs.eg.db")
library("org.Hs.eg.db")

#install.packages("vsn")
#library("vsn")
#meanSdPlot(assay(vsd))

select = dplyr::select
```

```{r load_data, include=FALSE}
# Load ensembl gene database
ensembl_db <- read.csv("EnsDb.Hsapiens.v86.csv")

# Load transcriptomics count data
# Each row is a gene, each column a sample
df.counts.raw <- read.csv("data/GSE98183_Counts.geneSymbols.75bpPE.csv") 

# load sample design
design <- read.csv2("data/samples.csv")
colnames(design) <- c("Sample", "Name", "Group")

# Sample names
colnames(df.counts.raw)
colnames(df.counts.raw) <- c("gene", "MK", "MKH", "Kb", "Ka", "cont")

# generate output dir path named data
source.output.dir <- file.path("data")

# if source output dir does not exist, create it
if (!dir.exists(source.output.dir)) {
    dir.create(source.output.dir)
} else{
  print("Data folder already exists")
}
```

```{r}
# Summary of dataframe with columns as factors
df.counts.raw %>% lapply(as.character) %>% lapply(as.factor) %>% as.data.frame() %>% summary()
```

```{r}
# Compute and plot total counts per sample
df.counts.raw %>% column_to_rownames("gene") %>% colSums() %>% data.frame() %>% rename("Value" = ".") %>% rownames_to_column("Sample") %>% 
  ggplot(aes(x = Sample, y = Value, fill = Sample)) + geom_col() + labs(x = "Sample_ID", y = "Raw Counts", title = "Raw total counts") + theme(plot.title = element_text(hjust= 0.5), legend.position = "none") + scale_y_continuous(labels = scales::comma) + scale_fill_viridis_d()

```

## Ribosomal RNA 

Out of all the RNA present in a prokaryotic cell, roughly 85% is ribosomal (r)RNAs. Thus when sequencing RNA 85% of the reads will be on non-coding rRNA, while we are interested in mRNA. To improve sensitivity and dynamic range on the mRNA levels we remove the rRNA, called ribosomal RNA depletion. We should check if this procedure was effective.

Create a barplot showing the percentage of counts for each rRNA to the total number of counts. 

What percentage of the reads is mapped to rRNA? Has each sample roughly the same amount of rRNA reads? What would be the effect of deviations in rRNA level when we compare the samples? Should we correct the data somehow for this?

Create a new data.frame in which you filter out all rRNA genes

```{r}
# Some of the gene names in the count data correspond to the gene_name, some to the gene_id

# Create a "gene" column in the ensembl_db that corresponds to either the id or the name,
# depending on how it was annotated in the count data
gene_ensembl_db <- df.counts.raw %>% select(gene) %>% inner_join(ensembl_db %>% mutate(gene = gene_name)) %>% rbind(
  df.counts.raw %>% select(gene) %>% inner_join(ensembl_db %>% mutate("gene" = gene_id))
  )

# Convert dataframe to long format
df.counts.long <- df.counts.raw %>% pivot_longer(cols = c(-gene), values_to = "Count",  names_to = "Sample")

# The top most expressed genes are rRNA, filter out?
df.counts.long %>% group_by(gene) %>% summarize(mean = mean(Count)) %>% ungroup() %>% 
  left_join(gene_ensembl_db, by = "gene") %>% arrange(-mean)

# Check types of genes
gene_ensembl_db$gene_biotype %>% as.factor() %>% levels()

# Plot the proportion of rRNA in each sample
df.counts.long %>% group_by(Sample) %>% left_join(gene_ensembl_db, by = "gene") %>%
  mutate(raw_total = sum(Count)) %>%
  filter(gene_biotype %in% c("rRNA", "Mt_rRNA")) %>% group_by(Sample, raw_total) %>% summarize(rRNA_sum = sum(Count)) %>%
  mutate(fraction_rRNA = rRNA_sum/raw_total) %>%
  ggplot(aes(x = Sample, y = fraction_rRNA, fill = Sample)) + geom_col() + labs(x = "Sequence ID", y = "Percentage of rRNA", title = "percentage of rRNA and Mt_rRNA") + theme(plot.title = element_text(hjust= 0.5), legend.position = "none") + scale_y_continuous(labels = scales::percent) + scale_fill_viridis_d()

```

## Filtering out low-count genes and rRNA

```{r}
# Check how many genes have a sample with at least X counts
df.counts.long %>%
  group_by(gene) %>% filter(any(Count > 23)) %>% 
  mutate(counts_log2 = log2(Count+1)) %>% ungroup() %>% select(gene) %>% n_distinct()

# filter out genes for which all the samples have 0 counts.
# Also create a column for log2 of pseudocounts
df.counts.f <- df.counts.long %>%
  group_by(gene) %>% filter(any(Count > 0)) %>% 
  mutate(counts_log2 = log2(Count+1)) %>% ungroup()

# Compare the dimensions of the datasets
dim(df.counts.long)
dim(df.counts.f)

df.counts.raw$gene %>% n_distinct()
df.counts.f$gene %>% n_distinct()

```

## Visualizing counts' distribution:

Visualize the distribution of the counts in log space.

Are the samples similar or different? Do you see outliers? Can you conclude that the values are consistent, or is a normalization step required?
```{r}
# make a boxplot using the counts_log2 column
df.counts.f %>% ggplot(aes(x = Sample, y = counts_log2, col = Sample)) + geom_boxplot() + labs(x = "Sample", y = "log2 Counts", title = "Distribution of Log2 Counts") + theme(legend.position = "none", plot.title = element_text(hjust= 0.5)) + scale_fill_brewer(palette = "Dark2")

# make a density using the counts_log2 column
df.counts.f %>% ggplot(aes(counts_log2, col = Sample)) + geom_density()
```

## Sample comparison 

An important aspect of quality control is comparing the samples. A direct way of comparing the samples is to plot the gene expression levels of one sample against the gene expression levels of another sample. 

```{r}
# use pivot_wider to change to long format. Take the values from the `counts_log2` column
df.counts.f.wide <- df.counts.f %>% select(-c(Count)) %>% pivot_wider(names_from = Sample, values_from = counts_log2)
```

```{r}
# make a scatterplot of MK vs MKH log2 counts
df.counts.f.wide %>% ggplot(aes(x = MK, y = MKH)) + geom_point(alpha = 0.75, size = 0.5) + geom_abline(intercept = 0, slope =1, col = "red") + labs(x = "MK Log2 Counts", y = "MKH Log2 Counts", title = "Log2 Counts") + theme(plot.title = element_text(hjust= 0.5))
```

```{r}
# Compare the expression of genes between all pairs of samples
df.counts.f.wide %>% select(-c(gene)) %>% ggpairs(
  lower = list(continuous = wrap("points", alpha = 0.3, size = 0.5))
)
```
## MA plots

Although this plot is very informative, it is often more informative and common to compare the gene expression values between samples (or conditions) using an MA plot. In an MA plot you plot the difference in gene expression for each gene on the y-axis. The total expression level is plotted on the x-axis. It was originally developed for microarray data (http://en.wikipedia.org/wiki/MA_plot), but is also widely used for RNA-seq data.

The advantage is that differences from zero in the y-axis directly indicate a difference in log2 fold change. Each dot indicates a gene, and dots on the left side in the graph have a low expression level, and genes on the right side in the graph have a high expression level.

To analyze all 6 samples, it is handy to compare them all with a common reference. This common reference is the based median expression level of each gene across all samples. Use the `df.counts.f` data.frame to first calculate the log2 of the median counts per gene and then calculate M and A per sample.

```{r}
# calculate the log2 of the median counts per gene 
  # calculate M and A per sample
df.MA <- df.counts.f %>% group_by(gene) %>% mutate(common_ref = log2(median(Count))) %>% ungroup()

# M: difference between samples
# A: total counts for both samples
# Make a scatterplot of M vs A. Straight line with intercept = 0
df.MA %>% ggplot(aes(x = (counts_log2 + common_ref), y = (counts_log2 - common_ref))) + geom_point(size = 0.75) + facet_wrap(~Sample) + geom_hline(yintercept = 0, col = "red", size = 1) + labs(x = "A (versus reference)", y = "M (versus reference)", title = "Log2 Counts MA Plot") + theme(plot.title = element_text(hjust= 0.5))

rm(df.MA)
rm(df.counts.long)
rm(df.counts.f.wide)
```

# Differential Expression

We are analyzing our data using the `DESeq2` package. The goal of is to find differentially expressed genes.

## Preparing the data for DESeq2

DESeq2 needs as inputs, at least, 3 objects:

- countData: a matrix containing genes in rows and samples in columns. Gene names should be set as the row names of the matrix.
- colData: a data.frame with two columns, one containing the sample names and the other one containing the experimental conditions (in our case, control and treatment).
- design: a formula indicating the name of the column in the colData object that contains the experimental conditions.

```{r}
# join design data
# Convert CIN-medium label to CIN-High, as done in the paper
design_c <- design %>% mutate(Group = ifelse(Group == "CIN-medium", "CIN-high", Group))

df.counts.f <- df.counts.f %>% left_join(design_c,  by = "Sample")
```

Create the object for countData. Transform the df.diff to wide format, set the genes as row names and convert to matrix.

```{r}
# select only the necessary columns
# tranform to wide format
# set the row names
# transform to to matrix.
df.diff.wide <- df.counts.f %>% 
  arrange(Group) %>% 
  select(gene, Count, Sample) %>% 
  pivot_wider(
    names_from = Sample, 
    values_from =  Count
    ) %>% column_to_rownames("gene") %>%
  as.matrix()

head(df.diff.wide)

```

```{r}
  # get the unique combinations of sample and group, arrange by group
  # convert sequence_id and purpose columns to factors.
  # Rows must be in the same order as the columns of the count matrix
df.diff.design <- df.counts.f %>% 
  distinct(Sample, Group) %>%
  arrange(Group)%>%
  mutate(
    Sample = as.factor(Sample),
    Group = as.factor(Group)
  )
head(df.diff.design)

```

Create the DESeq2 object and estimate size factors to apply counts normalization

```{r}
# create the deseq dataset
deseq.dataset <- DESeqDataSetFromMatrix(
  countData=as.matrix(df.diff.wide),
  colData=df.diff.design,
  design=~Group
) %>%
  estimateSizeFactors()

# Change factor levels to compare CIN-High x CIN-low (default is alphabetical)
deseq.dataset$Group <- factor(deseq.dataset$Group, levels = c("CIN-low","CIN-high"))

```

## Counts normalization

The previous function call creates a DESeq2 object which, among many other things, contains the normalized counts and the estimated size factors.

You can access the normalized counts from the DESeq object by calling the `counts` function with `normalized = TRUE`. 

```{r}
# Get the size factors by using the `sizeFactors()` function and the created DESeq object
deseq.dataset %>% sizeFactors() %>% 
  enframe(name = "Sample", value = "size_factor") %>% 
  arrange(Sample)

deseq.dataset.norm <- deseq.dataset %>%
  counts(normalized=TRUE) %>% as.data.frame()
deseq.dataset.norm

deseq.dataset.norm.long <- deseq.dataset.norm %>% rownames_to_column("gene") %>% pivot_longer(cols = c(-gene), values_to = "counts", names_to = "Sample")
deseq.dataset.norm.long
```

```{r}
# Plot total number of normalized counts, that used size factors from DESEq
deseq.dataset.norm.long %>% 
  group_by(Sample) %>%
  summarise(
    total_counts_norm = sum(counts)
  ) %>%
  ggplot(aes(x = Sample, y = total_counts_norm, fill= Sample)) +
  geom_col() +
  scale_fill_viridis_d() +
  labs(x= "", y = "Total Counts per Sample", title = "Total normalized counts") + theme(plot.title = element_text(hjust= 0.5), legend.position = "hide") + scale_y_continuous(labels = scales::comma, breaks = seq(from = 0, to = 150000000, by = 10^7))
```

Make a boxplot to visualize the distribution of normalized counts, for every sample:

```{r }
# make boxplots for sample using the log2 transformed normalized (pseudo)counts
deseq.dataset.norm.long %>% 
  ggplot(aes(x = Sample, y = log2(counts+1), color = Sample)) + 
  geom_boxplot() +
labs(x= "Sample ID", y = "Log2 Counts", title = "Log2 count distribution") + theme(plot.title = element_text(hjust= 0.5), legend.position = "hide")

# make a density using the log2 transformed normalized counts
deseq.dataset.norm.long %>% ggplot(aes(log2(counts+1), col = Sample)) + geom_density()
```

Are the samples similar or different? Do you see outliers? Can you conclude that the normalization worked?

## Dispersion estimation

In RNA-seq count data there is a dependency between the variance and the mean that is addressed in the statistical procedures that are used for differential gene expression analysis. This plot visualizes the (overdispersed) mean-variance dependency in your normalized data:

Computing mean and variance:

```{r}
# create DESeq object
dds <- DESeq(deseq.dataset)
```

```{r}
resultsNames(dds)
res <- results(dds)

summary(res)
```


```{r}
# Plot variance over mean of normalized counts to check overdispersion

norm.counts <- counts(deseq.dataset, normalized=TRUE)

df.mean.var <- tibble(
  mean_counts = rowMeans(norm.counts),
  var =  apply(norm.counts, 1, var)
)

df.mean.var %>% 
  ggplot(aes(x = mean_counts, y = var)) +
    geom_point(alpha = 0.2) +
  labs(
    title = "Mean-variance relationship",
    x = "Mean log2(normalized counts) per gene",
    y = "Variance of log2(normalized counts)"
  ) +
  geom_abline(intercept = 0, slope = 1, colour = "brown") +
  scale_x_log10() +
  scale_y_log10()

rm(df.mean.var)
```
DESeq2 resolves this issue using regression and shrinkage:

```{r}
plotDispEsts(dds, log = "xy")
```

## Differential expression

In order to extract the results of the DESeq analysis, we need to call the `results()` function on the previously created DESeq object. The following code extracts into a data.frame the log fold change, the p-values and adjusted p-values for differential expression. 

```{r}
?lfcShrink

resLFC <- lfcShrink(dds, coef = "Group_CIN.high_vs_CIN.low", type = "apeglm")

df.deseq.results <- resLFC %>%
  as.data.frame() %>%
  rownames_to_column("gene")

df.deseq.results %>% 
  head()

# df.deseq.results2 <- dds %>%
#   lfcShrink(contrast=c("Group","CIN-high","CIN-low"), type = "normal") %>%
#   as.data.frame() %>%
#   rownames_to_column("gene")
```

The results can be plotted in an MA plot:

```{r}
res %>% 
  plotMA(ylim=c(-5,5))

# MA plot on shrunken Log2 Fold Changes, also removes the ones with low counts
resLFC  %>% 
  plotMA(ylim=c(-5,5))
```
…and you can plot the expression values of for instance the 10 most differentially expressed genes:

```{r}
df.deseq.results %>% 
  select(gene, padj) %>% 
  arrange(padj) %>%
  slice(1:10) %>%
  left_join(
    deseq.dataset.norm.long, by = "gene"
  ) %>%
  left_join(
    design_c, by = "Sample"
  ) %>%
  mutate(
    gene = reorder(gene, padj)
  ) %>%
  ggplot(aes(x=Group, y=log2(counts), colour=padj)) +
  facet_wrap(~gene, ncol = 5) +
  geom_point() +
  scale_color_viridis_c(limits = c(0, 1)) +
  labs(
    x = "", y= bquote("log"[2]~"Normalized Counts"), colour = "Adjusted P. Value"
  ) +
  theme(legend.position = 'bottom')
```

```{r}
# Check how many genes have an adj p-value < 0.01
df.deseq.results %>% filter(padj < 0.01) %>% select(gene) %>% n_distinct()
```

Draw an histogram of the p-values and the adjusted p-values

```{r}
# histogram of pvalues
df.deseq.results %>% 
  ggplot(aes(pvalue)) + geom_histogram() +   labs(
    title = "DESeq2 p-value distribution", 
    x = "DESeq2 P-value", 
    y = "Number of genes"
  ) +  # you can add two ggplot objects with `+` with the patchwork package
  df.deseq.results %>% 
  ggplot(aes(padj)) + geom_histogram() +   labs(
    title = "DESeq2 Adjusted p-value distribution", 
    x = "DESeq2 adjusted P-value", 
    y = "Number of genes"
  )
 # histogram of adj pvalues
```

Create a volcano plot.

```{r}
alpha = 0.001
log2FCthresh = 2
df.deseq.results <- df.deseq.results %>% mutate(
  within_threshold = (padj < alpha & abs(log2FoldChange) > log2FCthresh)
)

#df.volcano <- df.deseq.results %>% mutate(threshold = (abs(log2FoldChange) > 2 & padj < alpha))

df.deseq.results %>% ggplot(
  aes(x=log2FoldChange , y= -log10(padj + 1e-200), col = within_threshold)) +     geom_point(alpha = 0.5) +
geom_vline(xintercept = 0, col = "black") + 
geom_vline(xintercept = c(-log2FCthresh, log2FCthresh), col = "red") +   geom_hline(yintercept = -log10(alpha), colour = "red") + 
geom_text_repel(
  aes(x = log2FoldChange, y = -log10(padj + 1e-200), label = gene), data = df.deseq.results %>% filter(within_threshold), colour = "grey20"
  ) +
  theme(legend.position = "none", plot.title = element_text(hjust= 0.5)) +
  labs(
    title = "Volcano plot", 
    x = "Effect size: log2(fold-change)", 
    y = "-log10(adjusted p-value)"
  ) + ylim(0, 50) + 
  scale_x_continuous(breaks = seq(-6,9, by = 1))

# png(filename="data/volcano_plot.png", width=600, height=600)
# ggsave(file="data/volcano_plot.png", width=6, height=4, dpi=300)

```

```{r}
  # filter
df.deseq.results %>%
  filter(within_threshold == TRUE) %>% nrow()

df.deseq.results %>%
  filter(within_threshold == TRUE) %>%
  arrange(-log2FoldChange, padj) %>% head()
```
```{r}
# browseVignettes("biomaRt")  # biomart tutorial

# Use biomart to get a mapping between ensembl and entrez ids
mart <- biomaRt::useMart(biomart = "ENSEMBL_MART_ENSEMBL",
                         dataset = "hsapiens_gene_ensembl")
#  mirror = c("uswest", "useast", "asia", "www")

biomaRt::listEnsembl()
biomaRt::listDatasets(mart)
biomaRt::searchDatasets(mart = mart, pattern = "hsapiens")
biomaRt::listFilters(mart)
biomaRt::listAttributes(mart)

biomaRt::listAttributes(mart) %>% filter(str_detect(name, "entrez"))

unique_ensembl_gene_ids <- gene_ensembl_db %>% select(gene_id) %>% unique()

ensembl_entrez_map <- biomaRt::getBM(filters = "ensembl_gene_id",
               attributes = c("ensembl_gene_id","entrezgene_id", "entrezgene_accession"),
               values = unique_ensembl_gene_ids$gene_id,
               mart = mart)

# Most ensembl ids do not map to entrez ids using biomaRt
ensembl_entrez_map %>% select(entrezgene_id) %>% n_distinct()
ensembl_entrez_map %>% filter(is.na(entrezgene_id)) %>% n_distinct()
ensembl_entrez_map %>% filter(!is.na(entrezgene_id)) %>% n_distinct()

entrez_id_counts <- ensembl_entrez_map %>% count(entrezgene_id) %>% rename(counts = n) 
entrez_id_counts %>% summary()
entrez_id_counts %>% group_by(counts) %>% summarize(n_counts = n())
entrez_id_counts %>% colSums()

rm(entrez_id_counts)

# BiomaRt is finding multiple entrez gene ids/acession for each ensemble id
ensembl_entrez_map %>% select(ensembl_gene_id) %>% mutate(duplicates = duplicated(ensembl_gene_id)) %>% filter(duplicates) %>% right_join(ensembl_entrez_map) 
```

```{r}
# Use AnnotationDbi to get a mapping between ensembl and entrez ids
columns(org.Hs.eg.db) # returns list of available keytypes

ensembl_entrez_dbi_map <- unique_ensembl_gene_ids

ensembl_entrez_dbi_map$entrezid <- mapIds(org.Hs.eg.db,
                    keys=unique_ensembl_gene_ids$gene_id, #Column with Ensembl gene ids
                    column="ENTREZID",
                    keytype="ENSEMBL",
                    multiVals="first")
?mapIds
ensembl_entrez_dbi_map$gene_symbol <- mapIds(org.Hs.eg.db,
                    keys=unique_ensembl_gene_ids$gene_id, #Column with Ensembl gene ids
                    column="SYMBOL",
                    keytype="ENSEMBL",
                    multiVals="first")

ensembl_entrez_dbi_map %>% filter(is.na(entrezid)) %>% n_distinct()
ensembl_entrez_dbi_map %>% filter(!is.na(entrezid)) %>% n_distinct()

# No duplicates using AnnotationDbi mapIDs
ensembl_entrez_dbi_map %>% select(gene_id) %>% mutate(duplicates = duplicated(gene_id)) %>% filter(duplicates) %>% right_join(ensembl_entrez_dbi_map) 

```

```{r}
df.deseq.results %>% nrow()

# compare mapping between biomaRt and annotation dbi
DE_symbol_mapping <- df.deseq.results %>% mutate(neglog10padj = ifelse(padj != 0,    -log10(padj), NA)) %>% left_join(gene_ensembl_db %>% select(gene, gene_id, gene_name, symbol)) %>% left_join(ensembl_entrez_dbi_map %>% rename("annot.dbi.entrezid" = entrezid, "annot.dbi.gene_symbol" = gene_symbol)) %>% left_join(ensembl_entrez_map %>% rename("gene_id" = ensembl_gene_id, "biomart.entrezgene_accession" = entrezgene_accession, "biomart.entrezgene_id" = entrezgene_id)) %>% select(gene, gene_name, symbol, biomart.entrezgene_accession, annot.dbi.gene_symbol, biomart.entrezgene_id, annot.dbi.entrezid)

#rm(DE_symbol_mapping)

```

## Export
```{r}
df.deseq.results_map <- df.deseq.results %>% left_join(gene_ensembl_db %>% select(gene, gene_id, gene_name, symbol)) %>% filter(is.na(gene_id))

# Some genes were not found in the ensembl database file, using neither the gene_name or gene_id. It´s likely they are from the older human build GRCh37 or have gene synonyms
df.deseq.results_map %>% filter(is.na(gene_id)) %>% select(gene, gene_id) %>%  write.csv2("data/genes_with_missing_ensembl_ids.csv", row.names = FALSE)

# Most of these gene names were ensembl_ids themselves. I manually annotated the other ones with gene symbols to add the ensembl_ids
missing_ensembl_gene_ids <- read.csv2("data/ids_for_genes_with_missing_ensembl_ids.csv")
missing_ensembl_gene_ids <- missing_ensembl_gene_ids %>% mutate(gene_name = NA)

# Create a map between ensembl and entrez ids. Also include the missing ensembl ids.
df.deseq.results_map <- df.deseq.results %>% filter(!(gene %in% missing_ensembl_gene_ids$gene)) %>% left_join(
  gene_ensembl_db %>% select(gene, gene_id, gene_name)
  ) %>% rbind(
  df.deseq.results %>% inner_join(missing_ensembl_gene_ids)
) %>% left_join(ensembl_entrez_dbi_map) 

# As there are multiple gene IDs mapping to the same gene name, this map increases in size and creates duplicates rows. Keep track of these genes
df.deseq.results_map <- df.deseq.results_map %>% select(gene) %>% mutate(duplicated_due_to_id = duplicated(gene)) %>% filter(duplicated_due_to_id) %>% right_join(df.deseq.results_map) %>% unique()

# Add a column for negative log10 of pvalues
df.deseq.results_map <- df.deseq.results_map %>% mutate(neglog10padj = ifelse(padj != 0, -log10(padj), NA))

# Export data
df.deseq.results_map %>% write_csv2("data/transcriptomics_deseq.csv")

# DE genes using symmetrical threshold
df.deseq.results_map %>% filter(within_threshold == TRUE) %>% write_csv2(paste0("data/CIN-diff_deseq_DE_", alpha, "_FC", log2FCthresh, ".csv"))

# Genes up-regulated in CIN-high
alpha_up = 0.001
log2FCthresh_up = 1.75
n_genes_up <- df.deseq.results_map %>% filter(padj < alpha_up & log2FoldChange > log2FCthresh_up) %>% nrow()

df.deseq.results_map %>% filter(padj < alpha_up & log2FoldChange > log2FCthresh_up) %>% select(gene, gene_name, gene_id, entrezid, gene_symbol) %>% write_csv2(paste0("data/CIN-high-up_", alpha_up, "_FC_", log2FCthresh_up, "_n", n_genes_up, ".csv"), quote = FALSE)

# Genes down-regulated in CIN-high
alpha_down = 0.05
log2FCthresh_down = -1
n_genes_down <- df.deseq.results_map %>% filter(padj < alpha_down & log2FoldChange < log2FCthresh_down) %>% nrow()

df.deseq.results_map %>% filter(padj < alpha_down & log2FoldChange < log2FCthresh_down) %>% select(gene, gene_name, gene_id, entrezid, gene_symbol) %>% write_csv2(paste0("data/CIN-high-down_", alpha_down, "_FC_", log2FCthresh_down, "_n", n_genes_down, ".csv"), quote = FALSE)

```

```{r}
# Export normalized counts in the specific .txt format for GSEA analysis
# Description column is required, wasn't able to import in GSEA with "na" value
# Adding pseudocounts (0.1) to prevent 0 values in GSEA
norm.pseudocounts <- norm.counts + 0.1

# Use ensembl gene_ids for GSEA instead of the gene names
# be careful with data duplication! When the same gene maps to different ids, the rows are duplicated. These different IDs will count as individual observations, but they all come from the same measurement (under the same gene "name")

norm.pseudocounts.df <- norm.pseudocounts %>% as.data.frame() %>% rownames_to_column("gene") %>% filter(!(gene %in% missing_ensembl_gene_ids$gene)) %>% left_join(
  gene_ensembl_db %>% select(gene, gene_id, gene_name)
  ) %>% rbind(
  norm.pseudocounts %>% as.data.frame() %>% rownames_to_column("gene") %>% inner_join(missing_ensembl_gene_ids)
) %>% select(-c(gene, gene_name)) %>% 
  relocate(gene_id, 1) %>% rename("NAME" = gene_id)


# Take the sum of all counts for genes with the same name (gene_id)
norm.pseudocounts.df <- norm.pseudocounts.df %>% group_by(NAME) %>% summarize_all(.funs = sum) %>% ungroup() %>% mutate("DESCRIPTION" = 1) %>% relocate(DESCRIPTION, .after = NAME)

# Export normalized (pseudo)counts
norm.pseudocounts.df %>% write.table(file ="data/GSEA_CIN_high_low_pseudo.txt", sep = "\t", row.names = FALSE, quote = FALSE)


# Export ranked list for pre-ranked GSEA using shrunk log2fold changes 
# Duplications of ensembl IDs are problematic here, but there is no way to resolve the ambiguity
df.deseq.results_map %>% arrange("gene")

# Many duplicated gene IDs are due to "LRG" IDs, we can exclude these and use only the ensembl ID
df.deseq.results_map.f <- df.deseq.results_map %>% filter(!str_detect(gene_id, "LRG")) %>% select(-duplicated_due_to_id)

df.deseq.results_map.f <- df.deseq.results_map.f %>% select(gene) %>% mutate(duplicated_due_to_id = duplicated(gene)) %>% filter(duplicated_due_to_id) %>% right_join(df.deseq.results_map.f) %>% unique()

# As the preranked GSEA can be run with gne symbols, use those instead of the IDs
# drop data from duplicated IDs
df.deseq.results_map.f %>% arrange(-log2FoldChange) %>% select(gene_id, log2FoldChange) %>% rename("NAME" = gene_id) %>% unique() %>% write.table(file ="data/GSEA_preranked_CIN_high_low.rnk", sep = "\t", row.names = FALSE, quote = FALSE)

df.deseq.results_map.f %>% mutate(inverse_padj_sign = 1/pvalue *sign(log2FoldChange)) %>% select(log2FoldChange, pvalue, inverse_padj_sign) %>% summary()


df.deseq.results_map.f %>% mutate(pvalue = ifelse(is.na(pvalue), 1, pvalue)) %>% mutate(inverse_padj_sign = 1/pvalue *sign(log2FoldChange)) %>% arrange(-inverse_padj_sign) %>% select(gene_id, inverse_padj_sign) %>% rename("NAME" = gene_id) %>% unique() %>% write.table(file ="data/GSEA_preranked_CIN_high_low_pval.rnk", sep = "\t", row.names = FALSE, quote = FALSE)

df.deseq.results_map.f %>% arrange(-log2FoldChange) %>% filter(duplicated_due_to_id)

# norm.pseudocounts.df %>% pivot_longer(cols = c(-NAME, DESCRIPTION), names_to = "Sample", values_to = "Pseudocounts") %>% group_by(Sample) %>% filter(any(Pseudocounts == 0))

# Human_ENSEMBL_Gene_ID_MSigDB.v7.4 <- read.table("Human_ENSEMBL_Gene_ID_MSigDB.v7.4.chip", sep = "\t", header = TRUE)
 
# test <- Human_ENSEMBL_Gene_ID_MSigDB.v7.4 %>% rename("gene_id" = Probe.Set.ID) %>% left_join(gene_ensembl_db)

```

```{r}
# GSEA results
GSEA_pos <- read.table("data/CIN_high_low_preranked_log2FC.GseaPreranked/gsea_report_for_na_pos_1618265603872.tsv", header = TRUE, sep = "\t")

GSEA_neg <- read.table("data/CIN_high_low_preranked_log2FC.GseaPreranked/gsea_report_for_na_neg_1618265603872.tsv", header = TRUE, sep = "\t")

GSEA_res <- rbind(GSEA_pos, GSEA_neg) %>% mutate(within_threshold = FDR.q.val < 0.3) %>% mutate("Enriched_in" = ifelse(NES > 0, "CIN-high", "CIN-low"))

GSEA_res %>% select(-c(X, within_threshold)) %>% arrange(-NES) %>%  write_csv2("data/GSEA_CIN_DE_hallmarks.csv")


# GSEA_res <- GSEA_res %>% mutate(cropped_name = sub("HALLMARK_", "", NAME)
GSEA_res_names <- GSEA_res %>% filter(within_threshold) 
GSEA_res_names$cropped_name = c("Kras signaling", "Angiogenesis", "Androgen response", "Inflammatory response", "EMT", "Wnt/B-catenin", "OxPhos", "Myc targets v1", "ROS", "Apical Surface", "Myc targets v2")  

GSEA_res <- GSEA_res %>% left_join(GSEA_res_names)

		
GSEA_res %>% 
  ggplot(aes(x = log10(FDR.q.val), y = NES)) +
  geom_point(aes(size = 0.5, alpha = 0.3, col = Enriched_in)) + 
  geom_hline(yintercept = 0, col = "black") +
  geom_text_repel(
  aes(x = log10(FDR.q.val), y = NES, label = cropped_name), data = GSEA_res %>% filter(within_threshold), colour = "grey20", force = 3, force_pull = 2, min.segment.length = 0
  ) +
  labs(x = "log10(FDRq)", y = "Normalized Enrichment Score", col = "Enriched in") + 
  scale_y_continuous(limits = c(-2,2), breaks = seq(-2,2,1)) + 
  scale_x_continuous(trans = "reverse", limits = c(0, -3), breaks = c(-3, -2, -1, 0) , labels = c("<0.001", "0.01", "0.1", "1")) + scale_fill_manual(values = c("red","blue")) + guides(alpha = FALSE, size = FALSE)

# png(filename="data/GSEA_results.png", width=600, height=600)
# ggsave(file="data/GSEA_results.png", width=6, height=4, dpi=300)

```

```{r}
# Enrichr results
enrichr_diff <- read.table("data/Enrichr results/alpha0.001_FC2_diff/MSigDB_Hallmark_2020_table_ENRICHR.txt", sep = "\t", header = TRUE)

enrichr_up <- read.table("data/Enrichr results/alpha0.001_FC1.75_CIN_up/MSigDB_Hallmark_2020_table.txt", sep = "\t", header = TRUE)

enrichr_down <- read.table("data/Enrichr results/alpha0.05_FC-1_CIN_down/MSigDB_Hallmark_2020_table.txt", sep = "\t", header = TRUE)
```


```{r}
# Apply a variance stabilizing transform
vsd <- vst(dds, blind=FALSE)
vsd %>% assay() %>% head()

```

```{r}
# Heatmap on VSD data using top 20 genes
select <- order(rowMeans(counts(dds,normalized=TRUE)),
                decreasing=TRUE)[1:30]
df <- as.data.frame(colData(dds)[,c("Sample","Group")])
pheatmap(assay(vsd)[select,], cluster_rows=FALSE, show_rownames=FALSE,
         cluster_cols=FALSE, annotation_col=df)

```

```{r}
# Heatmap of sample distances
sampleDists <- dist(t(assay(vsd)))

sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- vsd$Group
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

```

Perform PCA on VST data 
```{r}
plotPCA(vsd, intgroup=c("Group"), returnData = TRUE)
plotPCA(vsd, intgroup=c("Group"))

plotPCA(vsd, intgroup=c("Group")) +
geom_text_repel(
  aes(x = PC1, y = PC2, label = name), data = plotPCA(vsd, intgroup=c("Group"), returnData = TRUE))
# png(filename="data/vst_pca.png", width=450, height=600)
# ggsave(file="data/vst_pca.png", width=4.5, height=4, dpi=300)

```

Perform PCA on log2 of normalized (pseudo)counts
```{r}
df.pca.data <- deseq.dataset.norm.long %>% mutate(counts_log2 = log2(counts + 1)) %>% select(-counts)

```

```{r}
df.pca <- df.pca.data %>% nest() %>% mutate(
      data = map(data, function(df.counts.f) { 
        df.counts.f %>%
          pivot_wider(
            names_from = all_of("gene"), 
            values_from = all_of("counts_log2")
          )}),
   
      pca = map(data, function(df.counts.f) { 
        df.counts.f %>% column_to_rownames("Sample") %>% prcomp
      }),
      # extract variance information
      pca_aug = map2(pca, data, ~augment(.x, data = .y)),
      # extract loading information
      pca_loadings = map(pca, function(df.counts.f) {
        df.counts.f$rotation %>% 
          as_tibble(rownames = "gene") %>%
          pivot_longer(
            cols = starts_with("PC"),
            names_to = "PC",
            names_prefix = "PC",
            values_to = "loading"
          ) %>%
          mutate(PC = as.numeric(PC))
      })
)

df.pca %>% glimpse()

```

```{r}
# Check the amount of variance explained by each principal component 
df.pca.var.exp <- df.pca %>% 
    unnest(pca_aug) %>%
    summarize_at(.vars = vars(starts_with(".fittedPC")), .funs = list(var)) %>%
    pivot_longer(
      cols = starts_with(".fittedPC"),
      names_to = "pc",
      names_prefix = ".fittedPC",
      values_to = "variance"
    ) %>% 
    mutate(
      pc = as.numeric(pc),
      var_exp = variance/sum(variance),
      cum_var_exp = cumsum(var_exp),
    )

df.pca.var.exp
```

```{r}
# Plot (cumulative) variance explained by each PC
df.pca.var.exp  %>% rename(
      `Variance Explained` = var_exp,
      `Cumulative Variance Explained` = cum_var_exp
    ) %>% 
    pivot_longer(
      cols = `Variance Explained`:`Cumulative Variance Explained`,
      names_to = "key",
      values_to = "value"
    ) %>% 
    ggplot(aes(as.factor(pc), value, group = key)) + 
    geom_point() + 
    geom_line() + 
    facet_wrap(~key) +
    theme_bw() +
    lims(y = c(0, 1)) +
    labs(
      x = "Principal Component",
      y = "Variance",
      title = "Variance explained by each principal component"
    )
```

```{r}
f_pca_plot <- function(
  pca.object, data, x.pc = 1, y.pc = 2, design = NULL, design.key = NULL, colour = NULL, label = NULL, title = NULL
){
  
  if(!is.null(design)) {
    stopifnot(!is.null(design.key))
    
    data <- left_join(data, design, by = design.key)
  }
  
  p <- autoplot(
    object = pca.object, data = data, 
    x = x.pc,
    y = y.pc, 
    loadings = FALSE, 
    colour = colour,
    label = !is.null(label),
    label.label = label,
    label.repel = !is.null(label)
  ) +
    theme_bw() +
    labs(
      x = glue::glue("Principal Component {x.pc}"),
      y = glue::glue("Principal Component {y.pc}"),
      #subtitle = glue::glue("PCA on PC {x.pc} and PC {y.pc}")
    )
  
  if (!is.null(title)) {
    p <- p + labs(title = title)
  }

  return(p)
}
```

```{r}
# Plot PCA scores on First and Second PCs
df.pca %>%
  mutate(
    pca_graph = map2(
      pca, data,
      f_pca_plot,
      x.pc = 1, y.pc = 2,
      design = design,
      design.key = "Sample",
      colour = "Group", label = "Sample"
    )
  ) %>% 
  pull(pca_graph) %>% first()

png(filename = "data/log2 PCA scores plot.png", width = 500, height = 300)
ggsave(file="data/log2 PCA scores plot.png", width= 5, height= 3, dpi=300)

```

  
```{r}
df.pca.loadings <- df.pca %>% 
  mutate(
    top_10_pc_1 = map(pca_loadings, function(.d) {
      .d %>% filter(PC == 1) %>% arrange(-loading) %>% slice(1:10)
    }),
    bottom_10_pc_1 =  map(pca_loadings, function(.d) {
      .d %>% filter(PC == 1) %>% arrange(loading) %>% slice(1:10)
    })
  )

```

```{r}
# Most down-regulated genes of PC 1:
df.pca.loadings %>% 
  unnest(bottom_10_pc_1) %>%
  select(gene, loading)

# Most up-regulated genes of PC 1:
df.pca.loadings %>% 
  unnest(top_10_pc_1) %>%
  select(gene, loading)
```

Another useful tool is to plot the expression levels in a heatmap.

```{r}
df.heatmap <- right_join(
  deseq.dataset.norm.long %>% select(gene, Sample, counts),
  bind_rows(
    df.pca.loadings %>% unnest(cols = top_10_pc_1) %>% select(gene, loading),
    df.pca.loadings %>% unnest(cols = bottom_10_pc_1) %>% select(gene, loading)
  ),
  by = "gene"
) %>%
  left_join(design) %>%
  select(gene, Sample, counts) %>%
  pivot_wider(
    names_from = Sample, 
    values_from = counts
  ) %>%
  ungroup()

df.heatmap %>%
  column_to_rownames(var = "gene") %>%
  as.matrix() %>% t() %>% scale() %>% t() %>%
  heatmap(col=diverging_hcl(n = 50, palette = "Blue-Red 3"))

```

```{r}
# Heatmap using more genes
df.pca.loadings.all <- df.pca %>% 
  mutate(
    loadings = map(pca_loadings, function(.d) {
      .d %>% filter(PC == 1) %>% arrange(-loading)
    })
  )

df.norm.heatmap <- right_join(
  deseq.dataset.norm.long %>% select(gene, Sample, counts),
    df.pca.loadings.all %>% unnest(cols = loadings) %>% select(gene, loading)
  , by = "gene"
) %>%
  left_join(design) %>%
  select(gene, Sample, counts) %>%
  pivot_wider(
    names_from = Sample, 
    values_from = counts
  ) %>%
  ungroup()


colfunc <- colorRampPalette(c("green", "black", "red"))

df.norm.heatmap <- df.norm.heatmap %>% column_to_rownames("gene") %>% rowMeans() %>% as.data.frame() %>% rename("mean_counts" = ".") %>% rownames_to_column("gene") %>% left_join(df.norm.heatmap)
  
# gc()
# memory.limit(9999999999)

df.norm.heatmap %>% filter(mean_counts > 100) %>% select(-mean_counts) %>% 
  column_to_rownames(var = "gene") %>%
  as.matrix() %>% t() %>% scale() %>% t() %>%
  heatmap.2(col=colfunc(50), dendrogram = "column", trace = "none")

```
