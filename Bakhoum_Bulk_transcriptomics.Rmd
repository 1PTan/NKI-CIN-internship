---
title: "Transcriptomics"
author: "Pedro Batista Tan. Adapted from the tutorial of Hugo Pineda, Joeri Jongbloets"
date: "`r strftime(Sys.Date(), '%B %d %Y')`"
output: 
  html_document:
    toc: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, warning=FALSE, message = FALSE
  # dpi = 300, fig.width = 10, fig.height = 6
)

# install.packages("BiocManager") #(only if you do not have BiocManager)
# BiocManager::install("DESeq2")
# BiocManager::install("apeglm")
library(DESeq2)
# install.packages("broom")
library(broom)
# install.packages("patchwork")
library(patchwork)
# install.packages("ggfortify")
library(ggfortify)
# install.packages("colorspace")
library(colorspace)
# install.packages("GGally")
library(GGally)
# install.packages("ggrepel")
library(ggrepel)
# install.packages("tidyverse")
library(tidyverse)
# install.packages("gplots")
library(gplots)
```

```{r load_data, include=FALSE}
source("pca.R")

# Load ensembl gene database
ensembl_db <- read.csv("EnsDb.Hsapiens.v86.csv")

# Load transcriptomics count data
# Each row is a gene, each column a sample
df.counts.raw <- read.csv("data/GSE98183_Counts.geneSymbols.75bpPE.csv") 

# load sample design
design <- read.csv2("data/samples.csv")
colnames(design) <- c("Sample", "Name", "Group")

# Sample names
colnames(df.counts.raw)
colnames(df.counts.raw) <- c("gene", "MK", "MKH", "Kb", "Ka", "cont")
```

```{r}
# Summary of dataframe with columns as factors
cols <- c("MK", "MKH", "Kb", "Ka", "cont")
df.counts.raw %>% lapply(as.character) %>% lapply(as.factor) %>% as.data.frame() %>% summary()
```

```{r}
# Compute total counts per sample
total_counts = df.counts.raw %>% column_to_rownames("gene") %>% colSums() %>% data.frame()
colnames(total_counts) <- c("Value")
total_counts <- total_counts %>% rownames_to_column("Sample") 

# Plot total counts per sample
total_counts %>% ggplot(aes(x = Sample, y = Value, fill = Sample)) + geom_col() + labs(x = "Sample_ID", y = "Raw Counts", title = "Raw total counts") + theme(plot.title = element_text(hjust= 0.5), legend.position = "none") + scale_y_continuous(labels = scales::comma) + scale_fill_viridis_d()
```

## Ribosomal RNA 

Out of all the RNA present in a prokaryotic cell, roughly 85% is ribosomal (r)RNAs. Thus when sequencing RNA 85% of the reads will be on non-coding rRNA, while we are interested in mRNA. To improve sensitivity and dynamic range on the mRNA levels we remove the rRNA, called ribosomal RNA depletion. We should check if this procedure was effective.

Create a barplot showing the percentage of counts for each rRNA to the total number of counts. 

What percentage of the reads is mapped to rRNA? Has each sample roughly the same amount of rRNA reads? What would be the effect of deviations in rRNA level when we compare the samples? Should we correct the data somehow for this?

Create a new data.frame in which you filter out all rRNA genes

```{r}
# Convert dataframe to long format
df.counts.long <- df.counts.raw %>% pivot_longer(cols = c(-gene), values_to = "Count",  names_to = "Sample")

# Some of the gene names in the count data correspond to the gene_name, some to the gene_id

# Create a "gene" column in the ensembl_db that corresponds to either the id or the name,
# depending on how it was annotated in the count data
gene_ensembl_db <- df.counts.raw %>% select(gene) %>% inner_join(ensembl_db %>% mutate(gene = gene_name)) %>% rbind(
  df.counts.raw %>% select(gene) %>% inner_join(ensembl_db %>% mutate("gene" = gene_id)
))

# The top most expressed genes are rRNA, filter out?
df.counts.long %>% group_by(gene) %>% summarize(mean = mean(Count)) %>% ungroup() %>% 
  left_join(gene_ensembl_db, by = "gene") %>% arrange(-mean)

# Check types of genes
gene_ensembl_db$gene_biotype %>% as.factor() %>% levels()

# Plot the proportion of rRNA in each sample
df.counts.long %>% group_by(Sample) %>% left_join(gene_ensembl_db, by = "gene") %>%
  mutate(raw_total = sum(Count)) %>%
  filter(gene_biotype %in% c("rRNA", "Mt_rRNA")) %>%
  mutate(fraction_rRNA = Count/raw_total) %>%
  ggplot(aes(x = Sample, y = fraction_rRNA, fill = Sample)) + geom_col() + labs(x = "Sequence ID", y = "Percentage of rRNA", title = "percentage of rRNA") + theme(plot.title = element_text(hjust= 0.5), legend.position = "none") + scale_y_continuous(labels = scales::percent) + scale_fill_viridis_d()

```

## Filtering out low-count genes and rRNA

```{r}
# Check how many genes have a sample with at least X counts
df.counts.long %>%
  group_by(gene) %>% filter(any(Count > 23)) %>% 
  mutate(counts_log2 = log2(Count+1)) %>% ungroup() %>% select(gene) %>% n_distinct()

# filter out genes for which all the samples have 0 counts.
# Also create a column for log2 of pseudocounts
df.counts.f <- df.counts.long %>%
  group_by(gene) %>% filter(any(Count > 0)) %>% 
  mutate(counts_log2 = log2(Count+1)) %>% ungroup()

# Compare the dimensions of the datasets
dim(df.counts.long)
dim(df.counts.f)

df.counts.raw$gene %>% n_distinct()
df.counts.f$gene %>% n_distinct()
```

## Visualizing counts' distribution:

Another way to check if data needs to be normalized is to visualize the distribution of the counts. This is usually done in log space.

Are the samples similar or different? Do you see outliers? Can you conclude that the values are consistent, or is a normalization step required?

```{r}
# make a boxplot using the counts_log2 column
df.counts.f %>% ggplot(aes(x = Sample, y = counts_log2, col = Sample)) + geom_boxplot() + labs(x = "Sample", y = "log2 Counts", title = "Distribution of Log2 Counts") + theme(legend.position = "none", plot.title = element_text(hjust= 0.5)) + scale_fill_brewer(palette = "Dark2")

```

Make a density plot to visualize the distribution in gene expression level, for every sample.

Are the samples similar or different? Do you see outliers? Can you conclude that the values are consistent, or is a normalization step required?

```{r }
# make a density using the counts_log2 column
df.counts.f %>% ggplot(aes(counts_log2, col = Sample)) + geom_density()
```

## Sample comparison 

An important aspect of quality control is comparing the samples. A direct way of comparing the samples is to plot the gene expression levels of one sample against the gene expression levels of another sample. 

```{r}
# use pivot_wider to change to long format. Take the values from the `counts_log2` column
df.counts.f.wide <- df.counts.f %>% select(-c(Count)) %>% pivot_wider(names_from = Sample, values_from = counts_log2)
```

```{r}
# make a scatterplot of MK vs MKH log2 counts
df.counts.f.wide %>% ggplot(aes(x = MK, y = MKH)) + geom_point(alpha = 0.75, size = 0.5) + geom_abline(intercept = 0, slope =1, col = "red") + labs(x = "MK Log2 Counts", y = "MKH Log2 Counts", title = "Log2 Counts") + theme(plot.title = element_text(hjust= 0.5))
```

```{r}
# Compare the expression of genes between all pairs of samples
df.counts.f.wide %>% select(-c(gene)) %>% ggpairs(
  lower = list(continuous = wrap("points", alpha = 0.3, size = 0.5))
)

```
## MA plots

Although this plot is very informative, it is often more informative and common to compare the gene expression values between samples (or conditions) using an MA plot. In an MA plot you plot the difference in gene expression for each gene on the y-axis. The total expression level is plotted on the x-axis. It was originally developed for microarray data (http://en.wikipedia.org/wiki/MA_plot), but is also widely used for RNA-seq data.

The advantage is that differences from zero in the y-axis directly indicate a difference in log2 fold change. Each dot indicates a gene, and dots on the left side in the graph have a low expression level, and genes on the right side in the graph have a high expression level.

Note that log2 expression values are plotted. Are the samples similar? What can you conclude from this plot?

To analyze all 6 samples, it is handy to compare them all with a common reference. This common reference is the based median expression level of each gene across all samples. Use the `df.counts.f` data.frame to first calculate the log2 of the median counts per gene and then calculate M and A per sample.

Make a plot comparing every sample to the common reference.

```{r}
# calculate the log2 of the median counts per gene 
  # calculate M and A per sample
df.MA <- df.counts.f %>% group_by(gene) %>% mutate(common_ref = log2(median(Count))) %>% ungroup()

# M: difference between samples
# A: total counts for both samples
# Make a scatterplot of M vs A. Straight line with intercept = 0
df.MA %>% ggplot(aes(x = (counts_log2 + common_ref), y = (counts_log2 - common_ref))) + geom_point(size = 0.75) + facet_wrap(~Sample) + geom_hline(yintercept = 0, col = "red", size = 1) + labs(x = "A (versus reference)", y = "M (versus reference)", title = "Log2 Counts MA Plot") + theme(plot.title = element_text(hjust= 0.5))
```

# Differential Expression

We are analyzing our data using the `DESeq2` package. The goal of is to find differentially expressed genes.

## Preparing the data for DESeq2

DESeq2 needs as inputs, at least, 3 objects:

- countData: a matrix containing genes in rows and samples in columns. Gene names should be set as the row names of the matrix.
- colData: a data.frame with two columns, one containing the sample names and the other one containing the experimental conditions (in our case, control and treatment).
- design: a formula indicating the name of the column in the colData object that contains the experimental conditions.

Create a data.frame containing the (filtered) counts data and the design data. It should look like this:

```{r}
# join design data
# Convert CIN-medium label to CIN-High, as in the paper
design_c <- design %>% mutate(Group = ifelse(Group == "CIN-medium", "CIN-high", Group))
  
df.diff <- df.counts.f %>% left_join(design_c,  by = "Sample")
df.diff

```

Create the object for countData. Transform the df.diff to wide format, set the genes as row names and convert to matrix.

```{r}
# select only the necessary columns
# tranform to wide format
# set the row names
# transform to to matrix.
df.diff.wide <- df.diff %>% 
  arrange(Group) %>% 
  select(gene, Count, Sample) %>% 
  pivot_wider(
    names_from = Sample, 
    values_from =  Count
    ) %>% column_to_rownames("gene") %>%
  as.matrix()

head(df.diff.wide)

```

```{r}
  # get the unique combinations of sample and group, arrange by group
  # convert sequence_id and purpose columns to factors.
  # Rows must be in the same order as the columns of the count matrix
df.diff.design <- df.diff %>% 
  distinct(Sample, Group) %>%
  arrange(Group)%>%
  mutate(
    Sample = as.factor(Sample),
    Group = as.factor(Group)
  )
head(df.diff.design)

```

Create the DESeq2 object and estimate size factors to apply counts normalization

```{r}
# create the deseq dataset
deseq.dataset <- DESeqDataSetFromMatrix(
  countData=as.matrix(df.diff.wide),
  colData=df.diff.design,
  design=~Group
) %>%
  estimateSizeFactors()

# Change factor levels to compare CIN High x CIN low (default is alphabetical)
deseq.dataset$Group <- factor(deseq.dataset$Group, levels = c("CIN-low","CIN-high"))

```

## Counts normalization

The previous function call creates a DESeq2 object which, among many other things, contains the normalized counts and the estimated size factors.

```{r}
# Get the size factors by using the `sizeFactors()` function and the created DESeq object
deseq.dataset %>% sizeFactors() %>% 
  enframe(name = "Sample", value = "size_factor") %>% 
  arrange(Sample)
```

You can access the normalized counts from the DESeq object by calling the `counts` function with `normalized = TRUE`. 

```{r}
deseq.dataset.norm <- deseq.dataset %>%
  counts(normalized=TRUE) %>% as.data.frame()
deseq.dataset.norm

deseq.dataset.norm.long <- deseq.dataset.norm %>% rownames_to_column("gene") %>% pivot_longer(cols = c(-gene), values_to = "counts", names_to = "Sample")
deseq.dataset.norm.long
```

```{r}
# Plot total number of normalized counts, that used size factors from DESEq
deseq.dataset.norm.long %>% 
  group_by(Sample) %>%
  summarise(
    total_counts_norm = sum(counts)
  ) %>%
  ggplot(aes(x = Sample, y = total_counts_norm, fill= Sample)) +
  geom_col() +
  scale_fill_viridis_d() +
  labs(x= "", y = "Total Counts per Sample", title = "Total normalized counts") + theme(plot.title = element_text(hjust= 0.5), legend.position = "hide") + scale_y_continuous(labels = scales::comma, breaks = seq(from = 0, to = 150000000, by = 10^7))
```

Make a boxplot to visualize the distribution of normalized counts, for every sample:

```{r }
# make boxplots for sample using the log2 transformed normalized (pseudo)counts
deseq.dataset.norm.long %>% 
  ggplot(aes(x = Sample, y = log2(counts+1), color = Sample)) + 
  geom_boxplot() +
labs(x= "Sample ID", y = "Log2 Counts", title = "Log2 count distribution") + theme(plot.title = element_text(hjust= 0.5), legend.position = "hide")

# make a density using the log2 transformed normalized counts
deseq.dataset.norm.long %>% ggplot(aes(log2(counts+1), col = Sample)) + geom_density()
```

Are the samples similar or different? Do you see outliers? Can you conclude that the normalization worked?

## Dispersion estimation

In RNA-seq count data there is a dependency between the variance and the mean that is addressed in the statistical procedures that are used for differential gene expression analysis. This plot visualizes the (overdispersed) mean-variance dependency in your normalized data:

Computing mean and variance:

```{r}
# create DESeq object
dds <- DESeq(deseq.dataset)
```

```{r}
resultsNames(dds)
results(dds)

summary(results(dds))
```

```{r}
# Plot variance over mean of normalized counts to check overdispersion

norm.counts <- counts(deseq.dataset, normalized=TRUE)

df.mean.var <- tibble(
  mean_counts = rowMeans(norm.counts),
  var =  apply(norm.counts, 1, var)
)

df.mean.var %>% 
  ggplot(aes(x = mean_counts, y = var)) +
    geom_point(alpha = 0.2) +
  labs(
    title = "Mean-variance relationship",
    x = "Mean log2(normalized counts) per gene",
    y = "Variance of log2(normalized counts)"
  ) +
  geom_abline(intercept = 0, slope = 1, colour = "brown") +
  scale_x_log10() +
  scale_y_log10()
```
DESeq2 resolves this issue using regression and shrinkage:

```{r}
plotDispEsts(dds, log = "xy")
```

Perform PCA on log2 of normalized (pseudo)counts 
```{r}
df.pca.data <- deseq.dataset.norm.long %>% mutate(counts_log2 = log2(counts + 1)) %>% select(-counts)
```

```{r}
df.pca <- df.pca.data %>% nest() %>% mutate(
      data = map(data, function(df.counts.f) { 
        df.counts.f %>%
          pivot_wider(
            names_from = all_of("gene"), 
            values_from = all_of("counts_log2")
          )}),
   
      pca = map(data, function(df.counts.f) { 
        df.counts.f %>% column_to_rownames("Sample") %>% prcomp
      }),
      # extract variance information
      pca_aug = map2(pca, data, ~augment(.x, data = .y)),
      # extract loading information
      pca_loadings = map(pca, function(df.counts.f) {
        df.counts.f$rotation %>% 
          as_tibble(rownames = "gene") %>%
          pivot_longer(
            cols = starts_with("PC"),
            names_to = "PC",
            names_prefix = "PC",
            values_to = "loading"
          ) %>%
          mutate(PC = as.numeric(PC))
      })
)

df.pca %>% glimpse()

```

```{r}
# Check the amount of variance explained by each principal component 
df.pca.var.exp <- df.pca %>% 
    unnest(pca_aug) %>%
    summarize_at(.vars = vars(starts_with(".fittedPC")), .funs = list(var)) %>%
    pivot_longer(
      cols = starts_with(".fittedPC"),
      names_to = "pc",
      names_prefix = ".fittedPC",
      values_to = "variance"
    ) %>% 
    mutate(
      pc = as.numeric(pc),
      var_exp = variance/sum(variance),
      cum_var_exp = cumsum(var_exp),
    )

df.pca.var.exp
```

```{r}
# Plot (cumulative) variance explained by each PC
df.pca.var.exp  %>% rename(
      `Variance Explained` = var_exp,
      `Cumulative Variance Explained` = cum_var_exp
    ) %>% 
    pivot_longer(
      cols = `Variance Explained`:`Cumulative Variance Explained`,
      names_to = "key",
      values_to = "value"
    ) %>% 
    ggplot(aes(as.factor(pc), value, group = key)) + 
    geom_point() + 
    geom_line() + 
    facet_wrap(~key) +
    theme_bw() +
    lims(y = c(0, 1)) +
    labs(
      x = "Principal Component",
      y = "Variance",
      title = "Variance explained by each principal component"
    )
```
```{r}
f_pca_plot <- function(
  pca.object, data, x.pc = 1, y.pc = 2, design = NULL, design.key = NULL, colour = NULL, label = NULL, title = NULL
){
  
  if(!is.null(design)) {
    stopifnot(!is.null(design.key))
    
    data <- left_join(data, design, by = design.key)
  }
  
  p <- autoplot(
    object = pca.object, data = data, 
    x = x.pc,
    y = y.pc, 
    loadings = FALSE, 
    colour = colour,
    label = !is.null(label),
    label.label = label,
    label.repel = !is.null(label)
  ) +
    theme_bw() +
    labs(
      x = glue::glue("Principal Component {x.pc}"),
      y = glue::glue("Principal Component {y.pc}"),
      subtitle = glue::glue("PCA on PC {x.pc} and PC {y.pc}")
    )
  
  if (!is.null(title)) {
    p <- p + labs(title = title)
  }

  return(p)
}
```

```{r}
# Plot PCA scores on First and Second PCs
df.pca %>%
  mutate(
    pca_graph = map2(
      pca, data,
      f_pca_plot,
      x.pc = 1, y.pc = 2,
      design = design,
      design.key = "Sample",
      colour = "Group", label = "Sample"
    )
  ) %>% 
  pull(pca_graph) %>% first()
#png(filename = "PCA scores plot.png", width = 1000, height = 600)
#ggsave(file="PCA scores plot.png", width= 10, height= 6, dpi=300)

```

```{r}
# Plot PCA scores on Second and Third PCs
df.pca %>%
  mutate(
    pca_graph = map2(
      pca, data,
      f_pca_plot,
      x.pc = 2, y.pc = 3,
      design = design,
      design.key = "Sample",
      colour = "Group", label = "Sample"
    )
  ) %>% 
  pull(pca_graph) %>% first()
```


```{r}
df.pca.loadings <- df.pca %>% 
  mutate(
    top_10_pc_1 = map(pca_loadings, function(.d) {
      .d %>% filter(PC == 1) %>% arrange(-loading) %>% slice(1:10)
    }),
    bottom_10_pc_1 =  map(pca_loadings, function(.d) {
      .d %>% filter(PC == 1) %>% arrange(loading) %>% slice(1:10)
    })
  )

```

```{r}
# Most down-regulated genes of PC 1:
df.pca.loadings %>% 
  unnest(bottom_10_pc_1) %>%
  select(gene, loading)

# Most up-regulated genes of PC 1:
df.pca.loadings %>% 
  unnest(top_10_pc_1) %>%
  select(gene, loading)
```

Another useful tool is to plot the expression levels in a heatmap.

```{r}
df.heatmap <- right_join(
  deseq.dataset.norm.long %>% select(gene, Sample, counts),
  bind_rows(
    df.pca.loadings %>% unnest(cols = top_10_pc_1) %>% select(gene, loading),
    df.pca.loadings %>% unnest(cols = bottom_10_pc_1) %>% select(gene, loading)
  ),
  by = "gene"
) %>%
  left_join(design) %>%
  select(gene, Sample, counts) %>%
  pivot_wider(
    names_from = Sample, 
    values_from = counts
  ) %>%
  ungroup()

df.heatmap %>%
  column_to_rownames(var = "gene") %>%
  as.matrix() %>% t() %>% scale() %>% t() %>%
  heatmap(col=diverging_hcl(n = 50, palette = "Blue-Red 3"))
#png(filename = "top 10 heatmap.png", width = 1000, height = 600)
#ggsave(file="top 10 heatmap.png", width= 10, height= 6, dpi=300)
```

```{r}
# Improved Heatmap
df.pca.loadings.all <- df.pca %>% 
  mutate(
    loadings = map(pca_loadings, function(.d) {
      .d %>% filter(PC == 1) %>% arrange(-loading)
    })
  )

df.norm.heatmap <- right_join(
  deseq.dataset.norm.long %>% select(gene, Sample, counts),
    df.pca.loadings.all %>% unnest(cols = loadings) %>% select(gene, loading)
  , by = "gene"
) %>%
  left_join(design) %>%
  select(gene, Sample, counts) %>%
  pivot_wider(
    names_from = Sample, 
    values_from = counts
  ) %>%
  ungroup()


colfunc <- colorRampPalette(c("green", "black", "red"))

df.norm.heatmap <- df.norm.heatmap %>% column_to_rownames("gene") %>% rowMeans() %>% as.data.frame() %>% rename("mean_counts" = ".") %>% rownames_to_column("gene") %>% left_join(df.norm.heatmap)
  
# gc()
# memory.limit(9999999999)

df.norm.heatmap %>% filter(mean_counts > 100) %>% select(-mean_counts) %>% 
  column_to_rownames(var = "gene") %>%
  as.matrix() %>% t() %>% scale() %>% t() %>%
  heatmap.2(col=colfunc(50), dendrogram = "column", trace = "none")

```


## Differential expression

In order to extract the results of the DESeq analysis, we need to call the `results()` function on the previously created DESeq object. The following code extracts into a data.frame the log fold change, the p-values and adjusted p-values for differential expression. 

```{r}
?lfcShrink

df.deseq.results <- dds %>%
  lfcShrink(coef = "Group_CIN.high_vs_CIN.low", type = "apeglm") %>%
  as.data.frame() %>%
  rownames_to_column("gene")

df.deseq.results %>% 
  head()

# df.deseq.results2 <- dds %>%
#   lfcShrink(contrast=c("Group","CIN-high","CIN-low"), type = "normal") %>%
#   as.data.frame() %>%
#   rownames_to_column("gene")
```

The results can be plotted in an MA plot:

```{r}
dds %>% 
  plotMA(ylim=c(-5,5))
```
â€¦and you can plot the expression values of for instance the 10 most differentially expressed genes:

```{r}
df.deseq.results %>% 
  select(gene, padj) %>% 
  arrange(padj) %>%
  slice(1:10) %>%
  left_join(
    deseq.dataset.norm.long, by = "gene"
  ) %>%
  left_join(
    design_c, by = "Sample"
  ) %>%
  mutate(
    gene = reorder(gene, padj)
  ) %>%
  ggplot(aes(x=Group, y=log2(counts), colour=padj)) +
  facet_wrap(~gene, ncol = 5) +
  geom_point() +
  scale_color_viridis_c(limits = c(0, 1)) +
  labs(
    x = "", y= bquote("log"[2]~"Normalized Counts"), colour = "Adjusted P. Value"
  ) +
  theme(legend.position = 'bottom')
```

```{r}
# Check how many genes have an adj p-value < 0.01
df.deseq.results %>% filter(padj < 0.01)
```

Draw an histogram of the p-values and the adjusted p-values

```{r}
# histogram of pvalues
df.deseq.results %>% 
  ggplot(aes(pvalue)) + geom_histogram() +   labs(
    title = "DESeq2 p-value distribution", 
    x = "DESeq2 P-value", 
    y = "Number of genes"
  ) +  # you can add two ggplot objects with `+` with the patchwork package
  df.deseq.results %>% 
  ggplot(aes(padj)) + geom_histogram() +   labs(
    title = "DESeq2 Adjusted p-value distribution", 
    x = "DESeq2 adjusted P-value", 
    y = "Number of genes"
  )
 # histogram of adj pvalues
```

Create a volcano plot.

```{r}
alpha = 0.01
log2FCthresh = 2
df.deseq.results <- df.deseq.results %>% mutate(
  within_threshold = (padj < alpha & abs(log2FoldChange) > log2FCthresh)
)

#df.volcano <- df.deseq.results %>% mutate(threshold = (abs(log2FoldChange) > 2 & padj < alpha))

df.deseq.results %>% ggplot(
  aes(x=log2FoldChange , y= -log10(padj + 1e-200), col = within_threshold)) +     geom_point(alpha = 0.5) +
geom_vline(xintercept = 0, col = "black") + 
geom_vline(xintercept = c(-log2FCthresh, log2FCthresh), col = "red") +   geom_hline(yintercept = -log10(alpha), colour = "red") + 
geom_text_repel(
  aes(x = log2FoldChange, y = -log10(padj + 1e-200), label = gene), data = df.deseq.results %>% filter(within_threshold), colour = "grey20"
  ) +
  theme(legend.position = "none", plot.title = element_text(hjust= 0.5)) +
  labs(
    title = "Volcano plot", 
    x = "Effect size: log2(fold-change)", 
    y = "-log10(adjusted p-value)"
  ) + ylim(0, 50) + 
  scale_x_continuous(breaks = seq(-6,9, by = 1))

```

```{r}
  # filter
df.deseq.results %>%
  filter(within_threshold == TRUE) %>%
  arrange(padj, log2FoldChange)

df.deseq.results %>%
  filter(within_threshold == TRUE) %>% nrow()
```

## Export

```{r}
df.deseq.results <- df.deseq.results %>% mutate(neglog10padj = ifelse(padj != 0,    -log10(padj), NA))

df.deseq.results %>%  write_csv("transcriptomics_deseq.csv")

alpha

df.deseq.results %>%  filter(within_threshold == TRUE) %>% write_csv("transcriptomics_deseq_f001.csv")

```
